<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="课程介绍
Spring源码分析

SpringBoot源码分析

SpringCloud源码分析

Redis底层结构分析


Spring源码分析IOC源码分析IOC/DI 的理解IOC控制反转，把对象的创建，属性设置，初始化，销毁等工作交给Spirng的IOC容器去管理，解放程序员的劳动力。对象">
    

    <!--Author-->
    
        <meta name="author" content="elder">
    

    <!--Open Graph Title-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="一个默默无闻的博客"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>一个默默无闻的博客</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link https://cdn.bootcdn.net/ajax/libs/featherlight/1.5.0/featherlight.gallery.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!--Favicon-->
    

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">一个默默无闻的博客</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">首页</a>
            </li>
            
            <li>
                <a href="/archives">归档</a>
            </li>
            
            <li>
                <a href="/girl">看妹子</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
            
                <li><a href="https://www.facebook.com/" class="fb" target="_blank" data-title="Facebook"></a></li>
            
            
                <li><a href="https://www.behance.net/" class="behance" target="_blank" data-title="Behance"></a></li>
            
            
                <li><a href="https://plus.google.com/+Pixelhint/posts" class="google" target="_blank" data-title="Google+"></a></li>
            
            
                <li><a href="https://dribbble.com/pixelhint" class="dribble" target="_blank" data-title="Dribble"></a></li>
            
            
            
            
        </ul><!-- end social -->

        <div class="rights">
            <p>Copyright © 2014 magnetic.</p>
            <p>Template by <a target="_blank" rel="noopener" href="http://pixelhint.com/magnetic-free-html5-responsive-photography-website-template/">Pixelhint.com</a></p>
            <p>Hexo Theme by <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan K.</a></p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('https://cdn.jsdelivr.net/gh/1042004021/cover/pic/wallhaven-1kxdz1.jpg');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/2021/08/15/authConfiguration/" class="previous" data-title="SpringBoot-@AutoConfiguration配置分析"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2021/06/01/interview-question-1/" class="next" data-title="JAVA进阶面试题（高频面试题）"></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">Untitled</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ul>
<li><p>Spring源码分析</p>
</li>
<li><p>SpringBoot源码分析</p>
</li>
<li><p>SpringCloud源码分析</p>
</li>
<li><p>Redis底层结构分析</p>
</li>
</ul>
<h2 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h2><h3 id="IOC源码分析"><a href="#IOC源码分析" class="headerlink" title="IOC源码分析"></a>IOC源码分析</h3><h4 id="IOC-DI-的理解"><a href="#IOC-DI-的理解" class="headerlink" title="IOC/DI 的理解"></a>IOC/DI 的理解</h4><p>IOC控制反转，把对象的创建，属性设置，初始化，销毁等工作交给Spirng的IOC容器去管理，解放程序员的劳动力。对象被注册到Spring的IOC容器中，使用的时候从容器中获取即可，非常方便。这些注册到Spring容器中的对象称之为Bean。</p>
<p>IOC容器如何做到这一点：当 Spring启动，IOC容器就会尝试加载Spring的配置文件(XML配置或者注解配置) ，并解析XML中Bean的定义，然后会把这些Bean的相关定义信息封装成对象（BeanDefinition） , 通过Bean注册器 BeanDefinitionRegistry 注册IOC容器中，也就是一个 ConcurrentHashMap&lt;String,BeanDefinition&gt; 中,这时候的Bean并没有创建真正的实例,只是完成了Bean的信息的封装而已。</p>
<p>对于Bean是单利(scope=sigletion) 或者多利(scope=prototype)IOC的处理方式是不一样的。在IOC容器将所有到Bean都注册到容器中(ConcurrentHashMap)之后，然后会找出scope=sigletion，且lazy=false（Bean默认）的Bean，根据其 BeanDefinition 进行Bean的实例化。 然后会把实例化好的Bean缓存到一个ConcurrentHashMap，方便以后再次获取。</p>
<p>对于scope=prototype，或者 lazy=true 的Bean是会在使用到Bean的时候才会实例化，IOC启动的时候不会实例化这种Bean。</p>
<p>Bean是根据 BeanDefinition 进行实例化的，我们注册给Spring的对象通常都是需要创建代理的(需要事务管理)，Spring会根据原生类是否有接口来选择使用JDK动态代理或者CGLIB代理方式为对象生成代理类，当然底层会通过反射手段来创建实例。</p>
<p>对象和对象之间有依赖关系，既然Spring帮我们管理Bean，那么Spring也需要我们维护Bean的依赖关系，比如：Controller中需要注入一个Service,那么IOC容器会在创建Controller时会先创建Service的实例，或者从IOC容器中找到Service的实例，然后赋值给Contorller。</p>
<h4 id="IOC核心类"><a href="#IOC核心类" class="headerlink" title="IOC核心类"></a>IOC核心类</h4><p><img src="https://cdn.jsdelivr.net/gh/1042004021/cover/pic/20210529225454284.png" alt="img"></p>
<ul>
<li><p>BeanFactory </p>
<p> IOC容器顶层接口，提供了Bean获取的基础方法</p>
</li>
<li><p>DefaultListableBeanFactory</p>
<p>是整个 bean 加载的核心部分，是 Spring 注册及加载Bean 的默认实现,DefaultListableBeanFactory继承了 AbstractAutowireCapableBeanFactory 并实现了 ConfigurableListableBeanFactory以及BeanDefinitionRegistry 接口</p>
</li>
<li><p>ApplicationContext</p>
<p>这个容器工厂也是继承了EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource，ApplicationEventPublisher, ResourcePatternResolver 接口，除了实现IOC基本功能外，还扩展了国际化支持，资源访问，事件发布等等。</p>
</li>
<li><p>BeanDefinitionRegistry</p>
<p>负责注册BeanDefinition ，并定义了对 BeanDefinition 的各种增删改操作，BeanDefinition 是对Ben的封装</p>
</li>
<li><p>ClasspathXmlApplicationContext</p>
<p>ClasspathXmlApplicationContext也是IOC容器工厂中的一员，默认 从classpath中获取XML配置，使用 XmlBeanDefinitionReader 进行解析配置，这是一个简单的、一站式便利的ApplicationContext。</p>
</li>
<li><p>XmlBeanDefinitionReader</p>
<p>XmlBeanDefinitionReader 用于 XML 定义的 Bean 的读取。 将实际的 XML 文档读取委托给BeanDefinitionDocumentReader接口的实现</p>
</li>
<li><p>ResourceLoader</p>
<p> 资源(XML配置文件)加载器，根据给定的配置文件地址，返回Resource对象</p>
</li>
<li><p>DocumentLoader</p>
<p> 把资源文件转换成Document文档对象</p>
</li>
<li><p>BeanDefinitionDocumentReader</p>
<p> 定义了读取Document并注册BeanDefinition的功能，默认实现是DefaultBeanDefinitionDocumentReader</p>
</li>
<li><p>BeanDefinitionParserDelegate</p>
<p> 定义了解析XML元素的方法</p>
</li>
</ul>
<p>这里可以总结一下XML配置文件读取的流程：</p>
<ol>
<li>通过ResourceLoader 加载配置文件XML转为Resource  </li>
<li>通过DocumentLoader 把Resource转换为 Document对象 </li>
<li>通过 DefaultBeanDefinitionDocumentReader对Document进行解析，调用 BeanDefinitionParserDelegate解析XML元素。</li>
</ol>
<h4 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h4><p>定义xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.xxx.xxx.MyBean&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">scopt</span>=<span class="string">&quot;&quot;</span>  <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>  <span class="attr">destory-mehod</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>加载配置获取Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Spring配置文件，拿到Spring容器</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span>  ClassPathXmlApplicationContext(<span class="string">&quot;配置文件.xml&quot;</span>)</span><br><span class="line"><span class="comment">//从容器中拿到对象实例</span></span><br><span class="line">MyBean myBean = context.getBean(MyBean.class);</span><br></pre></td></tr></table></figure>

<h4 id="IOC启动流程"><a href="#IOC启动流程" class="headerlink" title="IOC启动流程"></a>IOC启动流程</h4><h5 id="Bean的注册"><a href="#Bean的注册" class="headerlink" title="Bean的注册"></a>Bean的注册</h5><p><img src="https://cdn.jsdelivr.net/gh/1042004021/cover/pic/20210602195811229.png" alt="img"></p>
<p>Bean的注册流程如下</p>
<ol>
<li>创建容器工厂：DefaultListableBeanFactory</li>
<li>走加载Bean流程，使用 ResourceResolver 把配置资源 Resource</li>
<li>调用 XmlBeanDefinitionReader根据 Resource 注册Bean</li>
<li>在 XmlBeanDefinitionReader 中 调用 DefaultBeanDefinitionDocumentReader 把Resource解析成Document</li>
<li>在委派 BeanDefinitionParserDelegate 把Document 解析成 BeanDefinition</li>
<li>调用BeanDefinitionRegistry注册BeanDefinition到DefaultListableBeanFactory工厂中的一个 Map&lt;String, BeanDefinition&gt; beanDefinitionMap</li>
</ol>
<p>Bean的注册源码跟踪流程如下：</p>
<ol>
<li><p>IOC入口：ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext)</p>
</li>
<li><p>容器刷新：org.springframework.context.support.AbstractApplicationContext#refresh</p>
</li>
<li><p>创建容器注册Bean : org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</p>
</li>
<li><p>Bean的注册：org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions</p>
<ol>
<li><p>把配置转成Resource ： org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResource</p>
</li>
<li><p>Bean的注册XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)</p>
</li>
<li><p>把 Resource变成Document：org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument</p>
</li>
<li><p>注册Bean:org.springframework.beans.factory.xml.XmlBeanDefinitionReader#registerBeanDefinitions</p>
<ol>
<li><p>注册Bean:org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#registerBeanDefinitions</p>
</li>
<li><p>解析Document: DefaultBeanDefinitionDocumentReader#parseDefaultElement</p>
</li>
<li><p>解析Bean ： BeanDefinitionParserDelegate#parseBeanDefinitionElement</p>
</li>
<li><p>封装BeanDefinition: org.springframework.beans.factory.support.BeanDefinitionReaderUtils#createBeanDefinition</p>
</li>
<li><p>注册BeanDefinition : DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions</p>
<ol>
<li><p>注册BeanDefinaition: org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition</p>
</li>
<li><p>把BeanDefinition缓存：org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition</p>
<p>缓存到 DefaultListableBeanFactory 中的 Map&lt;String, BeanDefinition&gt; beanDefinitionMap 中</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="单例Bean的初始化"><a href="#单例Bean的初始化" class="headerlink" title="单例Bean的初始化"></a>单例Bean的初始化</h5><p>Bean注册完成就会对单例Bean且 lazy=false的Bean进行实例化。</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210605131706445.png" alt="img"></p>
<p>单例Bean的实例化流程</p>
<ol>
<li>refresh方法中，注册完Bean之后会对单例bean进行实例化</li>
<li>走 DefaultListableBeanFactory工厂的preInstantiateSingletons方法创建单例Bean</li>
<li>最终走 AbstractAutowireCapableBeanFactory#createBean 方法，根据BeanDefinition创建Bean </li>
<li>最终是走SimpleInstantiationStrategy 策略类 的instantiate方法创建Bean</li>
<li>底层还有判断是否使用CGLIB方式创建Bean</li>
<li>创建好之后会走 AbstractAutowireCapableBeanFactory#populateBean 进行Bean的属性注入</li>
</ol>
<p>Bean注册完成就会对单例Bean且 lazy=false的Bean进行初始化</p>
<ol>
<li><p>单例Bean初始化入口：org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p>
</li>
<li><p>实例化单例Bean: org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p>
</li>
<li><p>从三级缓存分钟获取单例Bean:DefaultSingletonBeanRegistry#getSingleton ， 如果没有就调用ObjectFactory创建</p>
</li>
<li><p>获取Bean实例： org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p>
</li>
<li><p>创建Bean ： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean</p>
<ol>
<li><p>创建Bean ：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance</p>
</li>
<li><p>实例化Bean：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean</p>
</li>
<li><p>调用Bean实例化策略创建Bean: org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate</p>
<p>会根据原生类是否有接口，从而选择是否要CGLIB方式创建对象。</p>
</li>
<li><p>通过反射获取Bean的构造器实例化Bean ： org.springframework.beans.BeanUtils#instantiateClass</p>
</li>
</ol>
</li>
<li><p>AbstractAutowireCapableBeanFactory#createBean 实例化好Bean之后，调用 AbstractAutowireCapableBeanFactory#populateBean进行属性注入</p>
</li>
</ol>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>从宏观的角度来说，Bean的什么周期可以分为四个阶段：</p>
<ol>
<li>Bean的实例化</li>
<li>Bean的属性注入</li>
<li>Bean的初始化</li>
<li>Bean的销毁</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/1042004021/cover/pic/20210617133715497.png" alt="img"></p>
<p>下面是Bean较为详细的生命周期流程</p>
<ul>
<li><p>Bean的实例化</p>
<p>AbstractAutowireCapableBeanFactory#createBean</p>
</li>
<li><p>Bean的属性设置</p>
<p> AbstractAutowireCapableBeanFactory#populateBean</p>
</li>
<li><p>前置处理器</p>
<p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>
</li>
<li><p>Bean的初始化</p>
<p>AbstractAutowireCapableBeanFactory#initializeBean  -&gt; InitializingBean#afterPropertiesSet</p>
</li>
<li><p>自定义Init方法</p>
<p>AbstractAutowireCapableBeanFactory#invokeCustomInitMethod</p>
</li>
<li><p>后置处理器</p>
<p>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization</p>
</li>
<li><p>Bean的销毁</p>
<p>DefaultSingletonBeanRegistry#destroySingleton  -&gt;  destroyBean</p>
</li>
</ul>
<h3 id="Bean的属性注入"><a href="#Bean的属性注入" class="headerlink" title="Bean的属性注入"></a>Bean的属性注入</h3><h4 id="Bean实例化属性注入"><a href="#Bean实例化属性注入" class="headerlink" title="Bean实例化属性注入"></a>Bean实例化属性注入</h4><p>Bean的属性注入，或者叫依赖注入在Spring中被叫做DI，他是在Bean的实例化过程中为当前Bean的依赖Bean进行注入值的过程。Bean的属性注入是在Bean的实例化方法中：AbstractAutowireCapableBeanFactory#doCreateBean 调用 populateBean 方法完成的。流程如下：</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210612084301813.png" alt="在这里插入图片描述"></p>
<p>属性注入的大致流程如下：</p>
<ol>
<li>通过BeanDeifinition找到当前Bean所依赖的其他Bean(可能通过名字依赖，可能通过类型依赖)</li>
<li>调用BeanDefinitionValueResolver : BeanDefinition包含的值解析器，根据名字，或者类型去解析依赖的Bean,有可能是从容器中找到，也有可能走Bean的创建流程去创建依赖的Bean。</li>
<li>得到依赖的Bean实例之后，使用反射，给依赖的字段注入值。</li>
</ol>
<h4 id="Autowired-自动注入"><a href="#Autowired-自动注入" class="headerlink" title="Autowired 自动注入"></a>Autowired 自动注入</h4><p>注解自动注入是通过 BeanPostProcessor 后缀处理器来完成的 ， 下面是后置处理器的执行时机：</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210617133715497.png" alt="在这里插入图片描述"></p>
<p>后置处理器的注册是在 AbstractApplicationContext#refresh() 刷新容器的时候 ，调用：registerBeanPostProcessors() 来完成注册的。</p>
<p>Spring提供了一个  AutowiredAnnotationBeanPostProcessor 后缀处理器专门来处理 @Autowired 自动注入。详细流程如下：</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210618092246276.png" alt="在这里插入图片描述"></p>
<p>总结一下大致思路</p>
<ol>
<li>容器刷新过程中，向容器注册后置处理器 ，其中包括： AutowiredAnnotationBeanPostProcessor</li>
<li>Bean实例化过程中， 触发 AutowiredAnnotationBeanPostProcessor的执行，具体是在 AbstractAutowireCapableBeanFactory#populateBean方法中去调用的后置处理器</li>
<li>AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法被调用，它会走 findAutowiringMetadata 方法扫描当前类中是否有 @autowire 注解。</li>
<li>然后会通过反射得到自动注入的字段所依赖的Bean，调用 beanFactory 得到依赖Bean的实例</li>
<li>然后使用放射进行自动注入字段赋值 </li>
</ol>
<h3 id="Bean的循环依赖"><a href="#Bean的循环依赖" class="headerlink" title="Bean的循环依赖"></a>Bean的循环依赖</h3><p>循环依赖包括: 构造器注入循环依赖 setter 注入循环依赖 和 prototype模式Bean的循环依赖。Spring只解决了单利Bean的 setter 注入循环依赖，对于构造器循环依赖，和 prototype模式的循环依赖是无法解决的，在创建Bean的时候就会抛出异常BeanCurrentlyInCreationException</p>
<h4 id="Setter循环依赖"><a href="#Setter循环依赖" class="headerlink" title="Setter循环依赖"></a>Setter循环依赖</h4><p>Spring解决循环依赖主要是使用三级缓存，具体流程如下；</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/image-20210803114032222.png" alt="image-20210803114032222"></p>
<p>所谓的三级缓存 ，其实就是三个 Map</p>
<ul>
<li>一级缓存 ： 是一个   singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256)  ，缓存实例化好的单例的Bean，后续applicationContext.getBean 也是从这个Map中获取。</li>
<li>二级缓存 ：earlySingletonObjects = new HashMap&lt;String, Object&gt;(16) ： 缓存的是早期的Bean，也就是正在创建中的Bean，这个时候的Bean并不完整。</li>
<li>三级缓存 ：singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16) ： 缓存的是Bean的ObjectFactory 工厂，是用来创建Bean的实例的工厂。</li>
</ul>
<p>注意：构造器转入和 prototype注入是不支持循环依赖的 。构造器循环依赖会导致死循环。Prototype模式下Bean是不做缓存的，所以就没法暴露ObjectFactory，也就没办法实现循环依赖。</p>
<h4 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h4><ol>
<li><p>首先Spring会走Bean的实例化流程尝试创建 A 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找A 是否正在创建，如果没找到，则将 A 放入 “正在创建Bean池”中，然后准备实例化构造器参数 B。</p>
</li>
<li><p>Spring会走Bean的实例化流程尝试创建 B 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找B 是否正在创建，如果没找到，则将 B 放入 “正在创建Bean池”中，然后准备实例化构造器参数 A。</p>
</li>
<li><p>Spring会走Bean的实例化流程尝试创建 A 的实例 ，在创建实例之间先从 “正在创建Bean池” (一个缓存Map而已)中去查找A 是否正在创建。</p>
</li>
<li><p>此时：Spring发现 A 正处于“正在创建Bean池”，表示出现构造器循环依赖，抛出异常：“BeanCurrentlyInCreationException”</p>
</li>
</ol>
<h4 id="Prototype循环依赖"><a href="#Prototype循环依赖" class="headerlink" title="Prototype循环依赖"></a>Prototype循环依赖</h4><p>Prototype模式下Bean是不做缓存的，所以就没法暴露ObjectFactory，也就没办法实现循环依赖。</p>
<h3 id="AOP源码分析"><a href="#AOP源码分析" class="headerlink" title="AOP源码分析"></a>AOP源码分析</h3><p>AOP是为面向切面编程，为什么要面向切面，何为切面？我们知道对于OOP面向对象而言在某些开发场景中是有一定不足，由于面向对象的思想是纵向的，它面对的是一个一个的对象，当我们需要在多个类中引入同一个公共的业务时(比如：事务,操作日志等)，那么在每个类中都要引入公共的业务代码，从而造成代码大量重复，代码结构不优雅，不方便维护 ，这个时候就需要使用到面向切面的编程来解决这个问题。使用AOP可以把分散在多个类中的公共的代码剥离出来，和业务本身的代码解耦， 然后通过动态代理将公共业务代码作用到多个对象，代码结构也更加优雅。</p>
<p>所以可以认为 面向切面 是对 面向对象 的补充，它的思想是横向的，它面向的是一个切面，如果把一个对象看做一个点，那么多个对象就是一个面，是为切面，AOP多用于：事务，日志，监控，流控等等业务场景。</p>
<h4 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h4><p>AOP的实现原理是基于动态代理，动态代理就是在运行时期动态的为某个类(原生类)生成代理类以达到代码增强的目的，且代理类是持有原生类的，可以在代理类中调用原生类以及做一些增强业务。</p>
<p>动态代理分为JDK动态代理和CGLIB代理，CGLIB代理需要导入相关的jar包。两者的区别是JDK动态代理要求原始类(被代理类)需要实现至少一个接口。而CGLIB则是基于继承进行代理，原生类可以不实现任何接口。</p>
<p>对于Spring而言默认采用JDK动态代理，如果原生类没有实现任何接口，Spring会选择CGLIB代理，或者你可以通过配置文件强制指定使用CGLIB代理。</p>
<h4 id="AOP启动流程"><a href="#AOP启动流程" class="headerlink" title="AOP启动流程"></a>AOP启动流程</h4><p>举例：加入我们定义了一个切面用来对某个Service做增强 。</p>
<p> 那么当Spring启动 ，AopNamespaceHandler 会注册一个 ，AspectJAutoProxyBeanDefinitionParser ，它的作用就是Aop进行解析</p>
<p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210621183954307.png" alt="img"></p>
<h4 id="解析器注册"><a href="#解析器注册" class="headerlink" title="解析器注册"></a>解析器注册</h4><p>在 AopNamespaceHandler中会注册一个 AspectJAutoProxyBeanDefinitionParser ，它是针对 <em>&lt;aop:aspectj-autoproxy 的解析器</em>，在该解析器中会注册一个  <em>AspectJAnnotationAutoProxyCreator</em>(实现类AnnotationAwareAspectJAutoProxyCreator) ，代理自动创建器。该创建器做两个事情</p>
<ul>
<li>查找classpath中的切面类，解析增强方法 ， 并为原始类匹配适用的增强方法</li>
<li>根据增强器和原始类来创建代理类，底层会选择JDK动态代理或者换CGLIB代理进行创建。</li>
</ul>
<h4 id="切面的查找"><a href="#切面的查找" class="headerlink" title="切面的查找"></a>切面的查找</h4><p>AnnotationAwareAspectJAutoProxyCreator 是一个    BeanPostProcessor ，在Bean实例化过程中，也就是Bean的initMethod初始化之后调用postProcessAfterInitialization方法来执行AOP相关的业务。</p>
<p>AnnotationAwareAspectJAutoProxyCreator 会负责扫描系统中的字节码，通过@Aspect 查找系统中的切面类，以及增强方法。然后去匹配我们的原始类所适用的增强方法。</p>
<ol>
<li>查找增强器：AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</li>
<li>匹配原始类使用的增强器：AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</li>
<li>代理的创建：AbstractAutoProxyCreator#createProxy </li>
<li>创建代理：ProxyFactory.getProxy  选择JDK或者CGLIB</li>
</ol>
<p>补充说一下：代理后的代理类是如何被调用的</p>
<ul>
<li>Before : 使用 MethodBeforeAdviceInterceptor来调用</li>
<li>后置：使用AspectJAfterAdvice来调用</li>
</ul>
<h3 id="事务源码分析"><a href="#事务源码分析" class="headerlink" title="事务源码分析"></a>事务源码分析</h3><h4 id="Transcationl注解解析"><a href="#Transcationl注解解析" class="headerlink" title="Transcationl注解解析"></a>Transcationl注解解析</h4><p><img src="%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81.assets/20210702141947657.png" alt="在这里插入图片描述"></p>
<ol>
<li>在 TxNamespaceHandler 注册了AnnotationDrivenBeanDefinitionParser用来解析事务注解配置</li>
<li>在AnnotationDrivenBeanDefinitionParser中创建 InfrastructureAdvisorAutoProxyCreator，其本身是个BeanPostPorcessor，还创建了 TransactionAttributeSource ， TransactionInterceptor ， TransactionAttributeSourceAdvisor</li>
<li>在Bean实例化的过程中调用InfrastructureAdvisorAutoProxyCreator#postProcessAfterInitialization 来解析Bean是否有@Transational，从而判断是否要进行增强创建代理。</li>
<li>在AutoProxyCreator 内部的 AopUtils#canApply 方法中通过 BeanFactoryTransactionAttributeSourceAdvisor的TransactionAttributeSourcePointcut切入点的matches方法中进行解析方法上的@Transactional 来决定是否要增强。</li>
<li>该方法获取到BeanFactoryTransactionAttributeSourceAdvisor 中的AnnotationTransactionAttributeSource，调用其getTransactionAttribute来解析。内部通过 SpringTransactionAnnotationParser#parseTransactionAnnotation来解析 方法上的@Transactional，如果方法上没有就去类上找，或者去父类的方法和类上找。</li>
<li>如果找到了就缓存到AbstractFallbackTransactionAttributeSource的attributeCache中，如果没找到说明这类不需要被事务增强。</li>
</ol>
<h4 id="Transactional-事务流程"><a href="#Transactional-事务流程" class="headerlink" title="Transactional 事务流程"></a>Transactional 事务流程</h4><p>主要是通过 TransactionInterceptor来拦截器请求，核心事务流程在 TransactionAspectSupport#invokeWithinTransaction方法中</p>
<p>包括：</p>
<ol>
<li>事务的创建，嵌套事务处理</li>
<li>事务回滚</li>
<li>事务提交</li>
</ol>
<h2 id="SpringBoot源码"><a href="#SpringBoot源码" class="headerlink" title="SpringBoot源码"></a>SpringBoot源码</h2><h3 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h3><p>我能以前在整合SpringMVC的时候，是需要咋web.xml中配置 DispatchServlert前端控制器的，为什么在SpringBoot中不用配置了。因为SpringBoot自动配置了，那么你知道它的自动配置流程是怎么样的吗？</p>
<p>在启动类上，我们通常都会打上： @SpringBootApplication 注解，它是一个组合标签，包括：</p>
<ul>
<li><p>SpringBootConfuration ,本质是一个 Configuration ，代表Spring的配置类。</p>
</li>
<li><p>IOC自动扫描的注解 ，ComponentScan 会去扫描类上是否有：@Component ,@Respository ,@Service @Controller ,如果有，就会把这个类自动注册到Spring容器中。</p>
</li>
<li><p>EnableAutoConfiguration ：就是启动SpringBoot自动配置的注解</p>
</li>
</ul>
<p>在 EnableAutoConfiguration 注解上 import了一个选择器(AutoConfigurationImportSelector)    ,选择器中有一个 selectImports 方，这个方法会去返回很多的自动配置的的全限定名，这些类会自动注册到Spring容器中。</p>
<p>selectImports是怎么去找到这些所谓的自动配置类的呢？他会通过Spring的SPI接口，也就是通过一个SpringFactoryLoader去扫描 classpath中的所有的jar包中的    MET-INF/spring.factories 中的自动配置类，比如： DispatchServlert就对应了DispatchServlertAutoConfiguration自动配置类 ， 它通过@Bean+方法的方式注册了一个 DispatchServlert 到Spring容器中 。 </p>
<p>再比如：DataSourceAutoConfiguration 负责自动配置DataSource ,通过  @Bean+方法的方式注册</p>
<h3 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h3><p>1.开启秒表计时</p>
<p>2.starting监听器，</p>
<p>3.处理应用参数</p>
<p>4.加载环境对象</p>
<p>5.打印横幅</p>
<p>6.创建Spring容器对象：AnnotationConfigApplicationContext</p>
<p>7.容器刷新的前置工作</p>
<p>8.刷新容器</p>
<p>9.刷新容器后置工作 </p>
<p>10.秒表停止</p>
<p>11.started事件</p>
<p>12.调用runner去启动程序</p>
<p>13.runninglisteners.</p>
<h2 id="SpringCloud源码"><a href="#SpringCloud源码" class="headerlink" title="SpringCloud源码"></a>SpringCloud源码</h2><h3 id="Eureak服务注册"><a href="#Eureak服务注册" class="headerlink" title="Eureak服务注册"></a>Eureak服务注册</h3><h3 id="Eureak服务续约"><a href="#Eureak服务续约" class="headerlink" title="Eureak服务续约"></a>Eureak服务续约</h3><h3 id="Eureka服务发现"><a href="#Eureka服务发现" class="headerlink" title="Eureka服务发现"></a>Eureka服务发现</h3><h3 id="Ribbon源码分析"><a href="#Ribbon源码分析" class="headerlink" title="Ribbon源码分析"></a>Ribbon源码分析</h3><h3 id="Fegin源码分析"><a href="#Fegin源码分析" class="headerlink" title="Fegin源码分析"></a>Fegin源码分析</h3>

            <!-- Tags -->
            


<div class="tags">
    
</div>



            <!-- Comments -->
            <div>
                




    <hr />
    <h3>Comments:</h3>
    <div id="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine@1.1.7/dist/Valine.min.js'></script>
    <script>
    new Valine({
        el: '#valine' ,
        notify:false,
        verify:false,
        app_id: 'ohKdNvnATs6xIpXGmi3zoR8g-gzGzoHsz',
        app_key: 'Gt7d5LTaoWzVHvHj58eHJbwu',
        placeholder: 'Just go go',
        path:window.location.pathname,
        avatar:'mm' 
    });
    </script>

            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->

<script src="/js/jquery.js"></script>


<!-- Custom Code -->

<script src="/js/main.js"></script>


<!-- Gallery -->
<script src="https://cdn.bootcdn.net/ajax/libs/featherlight/1.5.0/featherlight.gallery.min.css" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>