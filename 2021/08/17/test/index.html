<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="J2SE1.String和StringBuilder和StringBuffer区别String是不可变字符串，底层是基于字符数组，且有final修饰，因此每次对String的操作都会在内存中开辟空间，生成新的对象
StringBuilder和StringBuffer是可变字符串，修改不会生成新的对象">
    

    <!--Author-->
    
        <meta name="author" content="elder">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="test"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="一个默默无闻的博客"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>test - 一个默默无闻的博客</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link https://cdn.bootcdn.net/ajax/libs/featherlight/1.5.0/featherlight.gallery.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!--Favicon-->
    

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

<!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">一个默默无闻的博客</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">首页</a>
            </li>
            
            <li>
                <a href="/archives">归档</a>
            </li>
            
            <li>
                <a href="/girl">看妹子</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

    <div class="footer clearfix">
        <ul class="social clearfix">
            
            
                <li><a href="https://www.facebook.com/" class="fb" target="_blank" data-title="Facebook"></a></li>
            
            
                <li><a href="https://www.behance.net/" class="behance" target="_blank" data-title="Behance"></a></li>
            
            
                <li><a href="https://plus.google.com/+Pixelhint/posts" class="google" target="_blank" data-title="Google+"></a></li>
            
            
                <li><a href="https://dribbble.com/pixelhint" class="dribble" target="_blank" data-title="Dribble"></a></li>
            
            
            
            
        </ul><!-- end social -->

        <div class="rights">
            <p>Copyright © 2014 magnetic.</p>
            <p>Template by <a target="_blank" rel="noopener" href="http://pixelhint.com/magnetic-free-html5-responsive-photography-website-template/">Pixelhint.com</a></p>
            <p>Hexo Theme by <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan K.</a></p>
        </div><!-- end rights -->
    </div ><!-- end footer -->
</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('https://cdn.jsdelivr.net/gh/1042004021/cover/pic/wallhaven-1kxdz1.jpg');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a class="previous disabled"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2021/08/15/authConfiguration/" class="next" data-title="SpringBoot-@AutoC..."></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">test</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <h1 id="J2SE"><a href="#J2SE" class="headerlink" title="J2SE"></a>J2SE</h1><h3 id="1-String和StringBuilder和StringBuffer区别"><a href="#1-String和StringBuilder和StringBuffer区别" class="headerlink" title="1.String和StringBuilder和StringBuffer区别"></a>1.String和StringBuilder和StringBuffer区别</h3><p>String是不可变字符串，底层是基于字符数组，且有final修饰，因此每次对String的操作都会在内存中开辟空间，生成新的对象</p>
<p>StringBuilder和StringBuffer是可变字符串，修改不会生成新的对象</p>
<p>​    StringBuffer是线程安全的，方法有synchronized修饰，性能较低</p>
<p>​    StringBuilder是线程不安全的，方法没有synchronized修饰，性能较高</p>
<h3 id="2-ArrayList和LinkedList区别，你一般用哪一个，为什么"><a href="#2-ArrayList和LinkedList区别，你一般用哪一个，为什么" class="headerlink" title="2.ArrayList和LinkedList区别，你一般用哪一个，为什么"></a>2.ArrayList和LinkedList区别，你一般用哪一个，为什么</h3><p>ArrayList是基于数组实现的，根据索引随机访问元素性能高，但是插入和删除元素性能差，因为这会涉及到移位操作</p>
<p>LinkedList是基于双链表实现的，不支持索引，随机访问元素需要从头查找，因此性能差，但是添加删除性能高因为不涉及移位操作</p>
<p>根据实际需要，如果项目中使用查找较多，使用ArrayList，如果使用增删较多，请使用LinkedList</p>
<h3 id="3-创建线程是几种方式"><a href="#3-创建线程是几种方式" class="headerlink" title="3.创建线程是几种方式"></a>3.创建线程是几种方式</h3><p>方式一：继承Thread类，覆写run方法，创建实例对象，调用该对象的start方法启动线程<br>方式二：创建Runnable接口的实现类，类中覆写run方法，再将实例作为此参数传递给Thread类有参构造创建线程对象，调用start方法启动</p>
<p>方式三：创建Callable接口的实现类，类中覆写call方法，创建实例对象，将其作为参数传递给FutureTask类有参构造创建FutureTask对象，再将FutureTask对象传递给Thread类的有参构造创建线程对象，调用start方法启动</p>
<p>方式一有单继承的局限性</p>
<p>方式二和方式三避免了单继承的局限，使用更广泛。而方式二适用于无需返回值的场景，方式三使用于有返回值的场景</p>
<h3 id="4-直接调用线程的start方法和run方法有什么区别"><a href="#4-直接调用线程的start方法和run方法有什么区别" class="headerlink" title="4.直接调用线程的start方法和run方法有什么区别"></a>4.直接调用线程的start方法和run方法有什么区别</h3><p>start是开启新线程</p>
<p>而调用run方法是一个普通方法调用，还是在主线程里执行</p>
<h3 id="5-ArrayList和Vector区别"><a href="#5-ArrayList和Vector区别" class="headerlink" title="5.ArrayList和Vector区别"></a>5.ArrayList和Vector区别</h3><p>ArrayList是线程不安全的，Vector是线程安全的</p>
<p>ArrayList底层数组容量不足时，会自动扩容0.5倍，Vector会自动扩容1倍</p>
<h3 id="6-说一下面向对象的几大特征"><a href="#6-说一下面向对象的几大特征" class="headerlink" title="6.说一下面向对象的几大特征"></a>6.说一下面向对象的几大特征</h3><p>继承：对类的抽象，将公共部分抽取出来，子类可以拥有父类的属性和行为，意义在于提高代码的复用性</p>
<p>封装：对外隐藏实现细节，提供公共访问的方式，意义在于提高安全性</p>
<p>多态：对象的多种形态，当编译时类型和运行时类型不一样，就是多态，意义在于屏蔽子类差异</p>
<h3 id="7-接口和抽象类"><a href="#7-接口和抽象类" class="headerlink" title="7.接口和抽象类"></a>7.接口和抽象类</h3><p>定义接口使用interface，定义抽象类使用abstract class</p>
<p>接口由全局常量，抽象方法，（java8后：静态方法，默认方法）</p>
<p>抽象类由构造方法，抽象方法，普通方法</p>
<p>接口和类是实现关系，抽象类和类是继承关系</p>
<h3 id="8-String-c-“A”-new-String-“B”-在内存开辟几个空间"><a href="#8-String-c-“A”-new-String-“B”-在内存开辟几个空间" class="headerlink" title="8.String c = “A”+new String(“B”) 在内存开辟几个空间"></a>8.String c = “A”+new String(“B”) 在内存开辟几个空间</h3><p>5个</p>
<p>字符串常量池中：A    B    AB</p>
<p>堆内存中：B    AB</p>
<h3 id="9-Equals和-的区别"><a href="#9-Equals和-的区别" class="headerlink" title="9.Equals和==的区别"></a>9.Equals和==的区别</h3><p>equals()方法，适用于引用数据类型，覆写Object中的equals()方法，判断对象中的内容是否相同</p>
<p>==是比较运算符，适用于基本数据类型和引用数据类型，基本数据类型时比较的是值，引用数据类型比较的是地址</p>
<h3 id="10-int和Integer的区别"><a href="#10-int和Integer的区别" class="headerlink" title="10.int和Integer的区别"></a>10.int和Integer的区别</h3><p>int是基本数据类型，变量中直接存放数值，变量初始化时值是0</p>
<p>Integer是引用数据类型，变量中存放的是该对象的引用，变量初始化时值时null</p>
<p>Integer是int类型的包装类，将int封装成Integer，符合java面向对象的特性，可以使用各种方法比如和其他数据类型间的转换</p>
<p>Integer和int的深入对比：</p>
<p>​    1.两个通过new生成的Integer对象，由于在堆中地址不同，所以永远不相等</p>
<p>​    2.int和Integer比较时，只要数值相等，结果就相等，因为包装类和基本数据类型比较时，会自动拆箱，将Integer转化为int</p>
<p>​    3.通过new生成的Integer对象和非通过new生成的Integer对象相比较时，由于前者存放在堆中，后者存放在Java常量池中，所以永远不相等</p>
<p>​    4.两个非通过new生成的Integer对象比较时，如果两个变量的数值相等且在-128到127之间，结果就相等。这是因为给Integer对象赋一个int值，java在编译时，会自动调用静态方法valueOf()，根据java api中对Integer类型的valueOf的定义，对于-128到127之间的整数，会进行缓存，如果下次再赋相同的值会直接从缓存中取，即享元模式</p>
<h3 id="11-说一下Java中的集合体系，以及他们的特点"><a href="#11-说一下Java中的集合体系，以及他们的特点" class="headerlink" title="11.说一下Java中的集合体系，以及他们的特点"></a>11.说一下Java中的集合体系，以及他们的特点</h3><p>我们按照两种接口来分类</p>
<p>Collection接口</p>
<p>​    List：</p>
<p>​        ArrayList：底层数据结构是数组，查询性能高，增删性能低</p>
<p>​        Vector：底层数据结构是数组，查询性能高，增删性能低</p>
<p>​        LinkedList：底层数据结构是双向链表，查询性能低，增删性能高</p>
<p>​    Set：</p>
<p>​        HashSet：无序不重复的，底层数据结构是数组+链表+红黑树，判断重复依据是hashCode()和equals()</p>
<p>​        TreeSet：有序不重复的，底层数据结构是数组+链表+红黑树，排序方式分为自然排序，比较器排序</p>
<p>Map接口</p>
<p>​    HashMap：key的值没有顺序，线程不安全</p>
<p>​    TreeMap：key的值可以自然排序，线程不安全</p>
<p>​    HashTable：它的key和value都不允许为null，线程安全</p>
<p>​    Properties：它的key和value都是String类型的，线程安全</p>
<h3 id="12-HashMap和HashTable的区别在多线程中又要保证线程安全，又要保证性能，应该用哪种Map"><a href="#12-HashMap和HashTable的区别在多线程中又要保证线程安全，又要保证性能，应该用哪种Map" class="headerlink" title="12.HashMap和HashTable的区别在多线程中又要保证线程安全，又要保证性能，应该用哪种Map?"></a>12.HashMap和HashTable的区别在多线程中又要保证线程安全，又要保证性能，应该用哪种Map?</h3><p>HashMap和HashTable都是实现了Map接口的集合框架，他们的区别</p>
<p>​    第一，HashTable是线程安全的，它的实现方法都加了synchronized关键字，因此它的性能较低</p>
<p>​                HashMap是线程不安全的，它实现方法没有加synchronized，因此它的性能较高</p>
<p>​    第二，HashMap的key和value都允许为null，HashTable中的key和value都不能为null</p>
<p>如果不考虑线程安全，建议使用HashMap，如果需要考虑线程安全的高并发实现，建议使用ConcurrentHashMap</p>
<h3 id="13-Synchronized-和-lock的区别"><a href="#13-Synchronized-和-lock的区别" class="headerlink" title="13.Synchronized 和 lock的区别"></a>13.Synchronized 和 lock的区别</h3><p>他们都是用来解决并发编程中的线程安全问题的，不同的是</p>
<p>synchronized是一个关键字，依靠Jvm内置语言实现，底层是依靠指令码来实现；Lock是一个接口，它基于CAS乐观锁来实现的</p>
<p>synchronized在线程发生异常时，会自动释放锁，不会发生异常死锁，Lock在异常时不会自动释放锁，我们需要在finally中释放锁</p>
<p>synchronized是可重入，不可判断，非公平锁，Lock是可重入，可判断的，可手动指定公平锁或者非公平锁</p>
<h3 id="14-悲观锁和乐观锁"><a href="#14-悲观锁和乐观锁" class="headerlink" title="14.悲观锁和乐观锁"></a>14.悲观锁和乐观锁</h3><p>悲观锁和乐观锁，指的是看待并发同步问题的角度</p>
<p>悲观锁认为，对同一个数据的并发操作，一定是会被其他线程同时修改的。所以在每次操作数据的时候，都会上锁，这样别人就拿不到这个数据。如果不加锁，并发操作一定会出问题。用阳间的话说，就是总有刁民想害朕</p>
<p>乐观锁认为，对同一个数据的并发操作，是不会有其他线程同时修改的。它不会使用加锁的形式来操作数据，而是在提交更新数据的时候，判断一下在操作期间有没有其他线程修改了这个数据</p>
<p>悲观锁一般用于并发小，对数据安全要求高的场景</p>
<p>乐观锁一般用于高并发，多读少写的场景，但需要注意ABA问题，通常使用版本号控制，或者时间戳来解决</p>
<h3 id="15-线程的几种状态"><a href="#15-线程的几种状态" class="headerlink" title="15.线程的几种状态"></a>15.线程的几种状态</h3><p>新建状态：线程刚创建，还没有调用start方法之前</p>
<p>就绪状态：也叫临时阻塞状态，当调用了start方法后，具备cpu的执行资格，等待cpu调度器轮询的状态</p>
<p>运行状态：就绪状态的线程，获得了cpu的时间片，真正运行的状态</p>
<p>冻结状态：也叫阻塞状态，指的是该线程因某种原因放弃了cpu的执行资格，暂时停止运行的状态，比如调用了wait，sleep方法</p>
<p>死亡状态：线程执行结束了，比如调用了stop方法</p>
<h3 id="16-sleep-和-wait的区别"><a href="#16-sleep-和-wait的区别" class="headerlink" title="16.sleep 和 wait的区别"></a>16.sleep 和 wait的区别</h3><p>第一，sleep方法是Thread类的静态方法，wait方法是Object类的方法</p>
<p>第二：sleep方法不会释放对象锁，wait方法会释放对象锁</p>
<p>第三：sleep方法必须捕获异常，wait方法不需要捕获异常</p>
<h3 id="17-Synchronized-加在方法上-锁的对象是什么-加在静态方法上锁住的对象是什么？Synchronized-this-和-Synchronized-User-class-的区别"><a href="#17-Synchronized-加在方法上-锁的对象是什么-加在静态方法上锁住的对象是什么？Synchronized-this-和-Synchronized-User-class-的区别" class="headerlink" title="17.Synchronized 加在方法上 锁的对象是什么,加在静态方法上锁住的对象是什么？Synchronized(this) 和 Synchronized (User.class) 的区别"></a>17.Synchronized 加在方法上 锁的对象是什么,加在静态方法上锁住的对象是什么？Synchronized(this) 和 Synchronized (User.class) 的区别</h3><p>实例方法上的锁，锁住的是这个对象实例，它不会被实例共享，也叫做对象锁</p>
<p>静态方法上的锁，锁住的是这个类的字节码对象，它会被所有实例共享，也叫做类锁</p>
<p>Synchronized(this) 中，this代表的是该对象实例，不会被所有实例共享</p>
<p>Synchronized (User.class)，代表的是对类加锁，会被所有实例共享</p>
<h3 id="18-Synchronized-和-volatitle-关键字的区别"><a href="#18-Synchronized-和-volatitle-关键字的区别" class="headerlink" title="18.Synchronized 和 volatitle 关键字的区别"></a>18.Synchronized 和 volatitle 关键字的区别</h3><p>这两个关键字都是用来解决并发编程中的线程安全问题的，不同点主要有以下几点</p>
<p>第一：volatile的实现原理，是在每次使用变量时都必须重主存中加载，修改变量后都必须立马同步到主存；</p>
<p>​    synchronized的实现原理，则是锁定当前变量，让其他线程处于阻塞状态</p>
<p>第二：volatile只能修饰变量，synchronized用在修饰方法和同步代码块中</p>
<p>第三：volatile修饰的变量，不会被编译器进行指令重排序，synchronized不会限制指令重排序</p>
<p>第四：volatile不会造成线程阻塞，高并发时性能更高，synchronized会造成线程阻塞，高并发效率低</p>
<p>第五：volatile不能保证操作的原子性，因此它不能保证线程的安全，synchronized能保证操作的原子性，保证线程的安全</p>
<h3 id="19-创建线程的3种方式-三种线程的区别？-start-和-run-方法区别"><a href="#19-创建线程的3种方式-三种线程的区别？-start-和-run-方法区别" class="headerlink" title="19.创建线程的3种方式   三种线程的区别？   start() 和 run()方法区别"></a>19.创建线程的3种方式   三种线程的区别？   start() 和 run()方法区别</h3><p>​    方式一：继承Thread类，覆写run方法，创建实例对象，调用该对象的start方法启动线程<br>​    方式二：创建Runnable接口的实现类，类中覆写run方法，再将实例作为此参数传递给Thread类有参构造创建线程对象，调用start方法启动</p>
<p>​    方式三：创建Callable接口的实现类，类中覆写call方法，创建实例对象，将其作为参数传递给FutureTask类有参构造创建FutureTask对象，再将FutureTask对象传递给Thread类的有参构造创建线程对象，调用start方法启动</p>
<p>​    方式一有单继承的局限性</p>
<p>​    方式二和方式三避免了单继承的局限，使用更广泛。而方式二适用于无需返回值的场景，方式三使用于有返回值的场景</p>
<p>start才是开启新线程，而调用run方法是一个普通方法调用，还是在主线程里执行</p>
<h3 id="20-Synchronized和Lock的区别"><a href="#20-Synchronized和Lock的区别" class="headerlink" title="20.Synchronized和Lock的区别"></a>20.Synchronized和Lock的区别</h3><p>他们都是用来解决并发编程中的线程安全问题的，不同的是</p>
<p>synchronized是一个关键字，依靠Jvm内置语言实现，底层是依靠指令码来实现；Lock是一个接口，它基于CAS乐观锁来实现的</p>
<p>synchronized在线程发生异常时，会自动释放锁，不会发生异常死锁，Lock在异常时不会自动释放锁，我们需要在finally中释放锁</p>
<p>synchronized是可重入，不可判断，非公平锁，Lock是可重入，可判断的，可手动指定公平锁或者非公平锁</p>
<h3 id="21-线程的生命周期-sleep-和-wait区别"><a href="#21-线程的生命周期-sleep-和-wait区别" class="headerlink" title="21.线程的生命周期   sleep 和 wait区别"></a>21.线程的生命周期   sleep 和 wait区别</h3><p>新建状态：线程刚创建，还没有调用start方法之前</p>
<p>就绪状态：也叫临时阻塞状态，当调用了start方法后，具备cpu的执行资格，等待cpu调度器轮询的状态</p>
<p>运行状态：就绪状态的线程，获得了cpu的时间片，真正运行的状态</p>
<p>冻结状态：也叫阻塞状态，指的是该线程因某种原因放弃了cpu的执行资格，暂时停止运行的状态，比如调用了wait，sleep方法</p>
<p>死亡状态：线程执行结束了，比如调用了stop方法</p>
<p>sleep 和 wait区别 </p>
<p>​    第一，sleep方法是Thread类的静态方法，wait方法是Object类的方法</p>
<p>​    第二：sleep方法不会释放对象锁，wait方法会释放对象锁</p>
<p>​    第三：sleep方法必须捕获异常，wait方法不需要捕获异常</p>
<h3 id="22-synchronized-锁的原理，JDK1-6之后做了什么样的优化"><a href="#22-synchronized-锁的原理，JDK1-6之后做了什么样的优化" class="headerlink" title="22.synchronized 锁的原理，JDK1.6之后做了什么样的优化?"></a>22.synchronized 锁的原理，JDK1.6之后做了什么样的优化?</h3><p>在字节码层面：</p>
<p>​    synchronized在修饰方法时，通过ACC_SYNCHRONIZED关键字来标识对方法进行加锁，当线程要执行该方法时，需要获得锁才能执行</p>
<p>​    synchronized在修饰同步代码块时，通过monitorenter和monitorexit指令来执行加锁，当线程执行到monitorenter指令时，需要获取monitor的所有权才能执行，当执行到monitorexit的时候就要释放锁</p>
<p>在JVM层面：</p>
<p>​    无论时同步方法，还是同步代码块，这两种实现方式都是为了获取Monitor对象，这个对象在JVM中是基于C++实现的，叫做ObjectMonitor，当获取锁执行enter方法，释放锁执行exit方法。当某个线程获取到对象的monitor时，会把owner变量设置为当前线程，同时计数器count加1，也就意味着当前线程获得了对象锁</p>
<p>在操作系统层面：</p>
<p>​    monitor依靠的是操作系统老大哥的大锁，Mutex lock来实现的，这把大锁太重，会让整个程序性能变得很低</p>
<p>因此在JDK1.6及以后的版本中，增加了锁升级的过程，依次为无锁，偏向锁，轻量级锁，重量级锁。而且还增加了锁粗化，锁消除等策略，这就节省了锁操作的开销，提高了性能</p>
<h3 id="23-乐观锁的使用场景-数据库-ES"><a href="#23-乐观锁的使用场景-数据库-ES" class="headerlink" title="23.乐观锁的使用场景(数据库,ES)"></a>23.乐观锁的使用场景(数据库,ES)</h3><p>场景一：ES中对version的控制</p>
<p>场景二：Mysql中版本号的控制</p>
<p>场景三：原子类中的CompareAndSwap操作</p>
<h3 id="24-什么是CAS"><a href="#24-什么是CAS" class="headerlink" title="24.什么是CAS"></a>24.什么是CAS</h3><p>CompareAndSwap，比较和交换，是一种乐观锁的实现</p>
<p>举个栗子，线程t1需要将内存中的变量A=1，修改为A=2</p>
<p>第一步，将主存中A的值A=1拷贝一份到工作内存中</p>
<p>第二步，修改工作内存中变量A的值为A=2</p>
<p>第三步，再次判断主存中A的值，如果此时A=1，就将A=2的值写入主存中</p>
<h3 id="25-AtomicInterger怎么保证并发安全性的"><a href="#25-AtomicInterger怎么保证并发安全性的" class="headerlink" title="25.AtomicInterger怎么保证并发安全性的"></a>25.AtomicInterger怎么保证并发安全性的</h3><p>通过CAS操作原理来实现的，就可见性和原子性两个方面来说</p>
<p>它的value值使用了volatile关键字修饰，也就保证了多线程操作时内存的可见性</p>
<p>同时它通过Unsafe.compareAndSwapInt来实现原子性。</p>
<p>​    Unsafe这个类是一个很神奇的类，而compareAndSwapInt这个方法可以直接操作内存，依靠的是C++来实现的，它调用的是Atomic类的cmpxchg函数。而这个函数的实现是跟操作系统有关的，比如在X86的实现就利用汇编语言的CPU指令lock cmpxchg，它在执行后面的指令时，会锁定一个北桥信号，最终来保证操作的原子性</p>
<h3 id="26-什么是乐观锁，什么是悲观锁，什么是重入锁，什么是自旋锁，怎么是阻塞。"><a href="#26-什么是乐观锁，什么是悲观锁，什么是重入锁，什么是自旋锁，怎么是阻塞。" class="headerlink" title="26.什么是乐观锁，什么是悲观锁，什么是重入锁，什么是自旋锁，怎么是阻塞。"></a>26.什么是乐观锁，什么是悲观锁，什么是重入锁，什么是自旋锁，怎么是阻塞。</h3><p>悲观锁和乐观锁，指的是看待并发同步问题的角度</p>
<p>悲观锁认为，对同一个数据的并发操作，一定是会被其他线程同时修改的。所以在每次操作数据的时候，都会上锁，这样别人就拿不到这个数据。如果不加锁，并发操作一定会出问题。用阳间的话说，就是总有刁民想害朕</p>
<p>乐观锁认为，对同一个数据的并发操作，是不会有其他线程同时修改的。它不会使用加锁的形式来操作数据，而是在提交更新数据的时候，判断一下在操作期间有没有其他线程修改了这个数据</p>
<p>可重入锁是指允许同一个线程多次获取同一把锁，比如一个递归函数里有加锁操作</p>
<p>自旋锁不是锁，而是一种状态，当一个线程尝试获取一把锁的时候，如果这个锁已经被占用了，该线程就处于等待状态，并间隔一段时间后再次尝试获取的状态，就叫自旋</p>
<p>阻塞，指的是当一个线程尝试获取锁失败了，线程就就进行阻塞，这是需要操作系统切换CPU状态的</p>
<h3 id="27-你用过JUC中的类吗，说几个："><a href="#27-你用过JUC中的类吗，说几个：" class="headerlink" title="27.你用过JUC中的类吗，说几个："></a>27.你用过JUC中的类吗，说几个：</h3><p>Lock锁</p>
<p>ConcurrentHashMap</p>
<p>AtomicInteger</p>
<p>。。。</p>
<h3 id="28-ThreadLocal的作用和原理？-ThreadLocal的使用场景"><a href="#28-ThreadLocal的作用和原理？-ThreadLocal的使用场景" class="headerlink" title="28.ThreadLocal的作用和原理？   ThreadLocal的使用场景"></a>28.ThreadLocal的作用和原理？   ThreadLocal的使用场景</h3><p>ThreadLocal，翻译成中国话，叫做线程本地变量，它是为了解决线程安全问题的，它通过为每个线程提供一个独立的变量副本，来解决并发访问冲突问题</p>
<p>原理：ThredLocal是和当前线程有关系的，每个线程内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，它用来存储每个线程中的变量副本，key就是ThreadLocal变量，value就是变量副本。</p>
<p>当我们调用get方法是，就会在当前线程里的threadLocals中查找，它会以当前ThreadLocal变量为key获取当前线程的变量副本</p>
<p>它的使用场景比如在spring security中，我们使用SecurityContextHolder来获取SecurityContext，</p>
<p>​    比如在springMVC中，我们通过RequestContextHolder来获取当前请求，</p>
<p>​    比如在 zuul中，我们通过ContextHolder来获取当前请求</p>
<h3 id="29-线程池的作用，常用的线程池有几种，分别是什么意思"><a href="#29-线程池的作用，常用的线程池有几种，分别是什么意思" class="headerlink" title="29.线程池的作用，常用的线程池有几种，分别是什么意思?"></a>29.线程池的作用，常用的线程池有几种，分别是什么意思?</h3><p>线程池它和连接池类似的，主要作用是控制并发数量，同时可以实现线程的复用，也能管理线程的生命周期</p>
<p>常见的线程池有四种：</p>
<p>CachedThreadPool：可缓存的线程池</p>
<p>​    它在创建的时候，没有核心线程，线程最大数量是Integer最大值，最大空闲时间是60S</p>
<p>FixedThreadPool：固定长度的线程池</p>
<p>​    它的最大线程数等于核心线程数，此时没有最大空闲时长为0</p>
<p>SingleThreadPool：单个线程的线程池</p>
<p>​    它的核心线程和最大线程数都是1，也就是说所有任务都串行的执行</p>
<p>ScheduledThreadPool：可调度的线程池</p>
<p>​    它的最大线程数是Integer的最大值，默认最长等待时间是10S，它是一个由延迟执行和周期执行的线程池</p>
<h3 id="30-线程池的执行流程"><a href="#30-线程池的执行流程" class="headerlink" title="30.线程池的执行流程"></a>30.线程池的执行流程</h3><p>当一个任务来临时，如果有空闲的核心线程，直接使用</p>
<p>如果没有空闲的线程了，就将任务移入队列，等待执行</p>
<p>如果队列也满了，就新建线程来执行任务</p>
<p>如果新线程加上核心线程已经达到了最大线程数，那接下来的任务就会执行拒绝策略</p>
<h3 id="31-解释一下线程池构造器的7个参数"><a href="#31-解释一下线程池构造器的7个参数" class="headerlink" title="31.解释一下线程池构造器的7个参数"></a>31.解释一下线程池构造器的7个参数</h3><p>CorePoolSize：核心线程数，它是不会被销毁的</p>
<p>MaximumPoolSize ：最大线程数，核心线程数+非核心线程数的总和</p>
<p>KeepAliveTime：非核心线程的最大空闲时间，到了这个空闲时间没被使用，非核心线程销毁</p>
<p>Unit：空闲时间单位</p>
<p>WorkQueue：是一个BlockingQueue阻塞队列，超过核心线程数的任务会进入队列排队</p>
<p>ThreadFactory：它是一个创建新线程的工厂</p>
<p>Handler：拒绝策略，任务超过最大线程数+队列排队数 ，多出来的任务该如何处理取决于Handler</p>
<h3 id="32-EurekaClient拉取注册表-amp-心跳续约用到了什么技术来实现？"><a href="#32-EurekaClient拉取注册表-amp-心跳续约用到了什么技术来实现？" class="headerlink" title="32.EurekaClient拉取注册表&amp;心跳续约用到了什么技术来实现？"></a>32.EurekaClient拉取注册表&amp;心跳续约用到了什么技术来实现？</h3><p>它用到了一个带有周期性任务的线程池ScheduledThreadPoolExecutor来实现的</p>
<h3 id="33-数据结构有哪几种分类？"><a href="#33-数据结构有哪几种分类？" class="headerlink" title="33.数据结构有哪几种分类？"></a>33.数据结构有哪几种分类？</h3><p>按照逻辑结构分：</p>
<p>​    集合：没有相互关系的一堆数据</p>
<p>​    线性结构：元素存在一对一的相互关系</p>
<p>​    树形结构：元素存在一对多的相互关系</p>
<p>​    图形结构：元素存在多对多的相互关系</p>
<p>按照物理结构分：</p>
<p>​    顺序存储结构：用一组地址连续的存储空间依次存储线性表的数据元素，也叫顺序存储结构，比如数组</p>
<p>​    链接存储结构：用一组任意的存储空间来存储线性表中的数据元素，不要求相邻元素在物理位置上也相邻，比如链表</p>
<p>​    数据索引存储结构：建立附加的索引来标识节点的地址，通过索引，可以很快检索数据</p>
<p>​    数据散列存储结构：将数据元素的存储位置与关键字之间建立确定的对应关系，加快查找的速度，又叫hash存储</p>
<h3 id="34-数组和链表在内存中的存储结构有什么区别？"><a href="#34-数组和链表在内存中的存储结构有什么区别？" class="headerlink" title="34.数组和链表在内存中的存储结构有什么区别？"></a>34.数组和链表在内存中的存储结构有什么区别？</h3><p>数组在内存中是一组连续的存储空间，它随机存取元素性能很高，但是插入和删除操作，需要移动其他元素，因此性能很低</p>
<p>链表在内存中的存储空间可以是不连续的，而在每一个元素中都保存相邻节点的指针，因此它的存储密度相对较小，查找的性能低，因为需要从第一个元素依次遍历，但是它的插入和删除操作性能很高，因为它不需要移动节点，只需要改变相邻节点指针就行了，同时它更容易造成内存的碎片化</p>
<h3 id="35-说一下散列存储-Hash存储-，-什么是Hash冲突-，-有什么解决方案"><a href="#35-说一下散列存储-Hash存储-，-什么是Hash冲突-，-有什么解决方案" class="headerlink" title="35.说一下散列存储(Hash存储) ， 什么是Hash冲突 ， 有什么解决方案"></a>35.说一下散列存储(Hash存储) ， 什么是Hash冲突 ， 有什么解决方案</h3><p>散列存储，它通过把关键码的值映射到表中的一个位置，来提高查询的速度。而这个映射函数叫做散列函数。</p>
<p>哈希冲突，也叫哈希碰撞，指的是两个不同的值，计算出了相同的hash，也就是两个不同的数据计算出同一个下标，通常解决方案有：</p>
<p>拉链法，把哈希碰撞的元素指向一个链表</p>
<p>开放寻址法，把产生冲突的哈希值作为值，再进行哈希运算，直到不冲突</p>
<p>再散列法，就是换一种哈希算法重来一次</p>
<p>建立公共溢出区，把哈希表分为基本表和溢出表，将产生哈希冲突的元素移到溢出表</p>
<h3 id="36-举例说说时间复杂度，比如：数组，链表，循环，嵌套循环-，-2个非嵌套循环-，-在什么情况下时间复杂度是什么？"><a href="#36-举例说说时间复杂度，比如：数组，链表，循环，嵌套循环-，-2个非嵌套循环-，-在什么情况下时间复杂度是什么？" class="headerlink" title="36.举例说说时间复杂度，比如：数组，链表，循环，嵌套循环 ， 2个非嵌套循环 ， 在什么情况下时间复杂度是什么？"></a>36.举例说说时间复杂度，比如：数组，链表，循环，嵌套循环 ， 2个非嵌套循环 ， 在什么情况下时间复杂度是什么？</h3><p>时间复杂度是用来度量算法执行的时间长短，通常我们用Ｏ(f(n))渐进时间复杂度来衡量，比如说</p>
<p>​    要在 hash 表中找到一个元素就是 O(1)</p>
<p>​    要在无序数组中找到一个元素就是 O(n)</p>
<p>​    访问数组的第 n 个元素是 O(1)</p>
<p>​    二分搜索的时间复杂度最好的情况是 O(1)，最坏情况（平均情况）下 O(log n)</p>
<p>​    访问链表的第 n 个元素是 O(n)</p>
<p>​    一个For循环是O(n)</p>
<p>​    两个For循环嵌套是O(n2)</p>
<p>​    三个Foreach嵌套是O(n3)</p>
<h3 id="37-JDK中线性结构的集合有哪些？"><a href="#37-JDK中线性结构的集合有哪些？" class="headerlink" title="37.JDK中线性结构的集合有哪些？"></a>37.JDK中线性结构的集合有哪些？</h3><p>数组：按照顺序物理结构存储，ArrayList</p>
<p>链表：按照链式物理结构存储，LinkedList</p>
<p>栈：FIFO先进先出的线性存储结构，分为用数组实现的顺序栈，用链表实现的链栈</p>
<p>队列：LIFO后进先出的线性存储结构，分为顺序队列和链式队列</p>
<p>串：特殊的线性存储结构，String，StringBuffer，StringBuilder</p>
<h3 id="38-你说一下树形结构和线性结构的优势？"><a href="#38-你说一下树形结构和线性结构的优势？" class="headerlink" title="38.你说一下树形结构和线性结构的优势？"></a>38.你说一下树形结构和线性结构的优势？</h3><p>线性结构，对于大量的输入数据，访问时间很长，效率很低</p>
<p>树形结构的优势在于它查找数据性能很高</p>
<h3 id="39-说一下树的分类，以及你对它们的理解（二叉查找树的优缺点，平衡树的优缺点，红黑树的优缺点，B-树的优缺点-，B-树的优缺点）平衡树-，红黑树"><a href="#39-说一下树的分类，以及你对它们的理解（二叉查找树的优缺点，平衡树的优缺点，红黑树的优缺点，B-树的优缺点-，B-树的优缺点）平衡树-，红黑树" class="headerlink" title="39.说一下树的分类，以及你对它们的理解（二叉查找树的优缺点，平衡树的优缺点，红黑树的优缺点，B-树的优缺点 ，B+树的优缺点）平衡树 ，红黑树"></a>39.说一下树的分类，以及你对它们的理解（二叉查找树的优缺点，平衡树的优缺点，红黑树的优缺点，B-树的优缺点 ，B+树的优缺点）平衡树 ，红黑树</h3><p>二叉树：树中任意节点最多只有两个分叉的树，它又分为二叉排序树，平衡二叉树，赫夫曼树，红黑树</p>
<p>​    二叉排序树，它是一个有序的二叉树，优势在于查找插入数据的性能很高，但是可能会出现倾斜而变成数组</p>
<p>​    平衡二叉树，二叉排序树进化形态，要求任何节点的两颗字数高度差不大于1。它的查询性能很高，但是每次增删元素，会重排序导致性能低</p>
<p>​    红黑树，自平衡二叉树，要求根节点和叶子节点是黑色，其他节点红黑交替，在任何一个子树中，从根节点向下走到空姐点的路径经过的黑节点数相同。从而保证了平衡。它的查询性能比平衡二叉树稍低，插入和删除元素的性能大幅提高。</p>
<p>​    赫夫曼树，它是根据数据出现的次数来构建二叉树，以权值作为根节点，构建N个二叉树，组成森林。它主要用来编码，比如压缩技术的实现</p>
<p>多叉树：解决二叉树存储大规模数据时，深度过大而导致IO性能低，查询效率低的问题，常见有B树和B+树，字典树，后缀树等等</p>
<p>​    B树，自平衡的树，适用于读写相对大的数据块，比如文件系统，数据库索引</p>
<p>​    B+树，B树升级版，它的内部节点只存储key，不存储具体数据，叶子节点存放key和具体数据。这就使得每个节点可以存更多的key，树的高度更低，查询更快，同时它每次查询都会到叶子节点，查询速度更稳定。并且所有的叶子节点会组成一个有序链表，方便区间查询</p>
<h3 id="40-有是二叉树为什么要出现多叉树"><a href="#40-有是二叉树为什么要出现多叉树" class="headerlink" title="40.有是二叉树为什么要出现多叉树"></a>40.有是二叉树为什么要出现多叉树</h3><p>因为二叉树在大规模的数据存储中，树会高的没谱，这会导致IO读写过于频繁，查询效率低下</p>
<p>多叉树可以解决这个问题，它每层可以存放更多的数据，因此能大幅度降低树的深度，提高查询性能</p>
<h3 id="41-b-tree和b-tree的区别？"><a href="#41-b-tree和b-tree的区别？" class="headerlink" title="41.b-tree和b+tree的区别？"></a>41.b-tree和b+tree的区别？</h3><p>B树每个节点都可以存放key，存放数据，而B+树所有内部节点只存放key，叶子节点存放key和数据，因此它能存放更多数据，降低树高，查询性能更快</p>
<p>M阶的B树，节点中存放元素的个数是M-1个，而M阶B+树，节点中存放的元素就是M个</p>
<p>B+树所有的叶子节点会构成一个链表结构，方便区间查找和排序</p>
<h3 id="42-说一下ES用到了什么数据结构？"><a href="#42-说一下ES用到了什么数据结构？" class="headerlink" title="42.说一下ES用到了什么数据结构？"></a>42.说一下ES用到了什么数据结构？</h3><p>ES是使用了数据索引存储结构，它是通过为关键字建立索引，通过索引找到对应的数据，这种索引也叫倒排索引，可以实现快速检索</p>
<h3 id="43-常见的算法了解几个？-手写一个冒泡，手写一个二分查找"><a href="#43-常见的算法了解几个？-手写一个冒泡，手写一个二分查找" class="headerlink" title="43.常见的算法了解几个？      手写一个冒泡，手写一个二分查找"></a>43.常见的算法了解几个？      手写一个冒泡，手写一个二分查找</h3><p>散列算法，将任意长度的输入，通过散列算法变成固定长度的输出。可以对节点快速检索</p>
<p>递归，一个方法自己调用自己</p>
<p>排序，常见排序方法有，插入排序，希尔排序，冒泡排序，比较排序。。。</p>
<p>查找，常见查找方法有，顺序查找，二分查找，插值查找，哈希查找。。。</p>
<h3 id="44-一个User的List集合，如何实现根据年龄排序？"><a href="#44-一个User的List集合，如何实现根据年龄排序？" class="headerlink" title="44.一个User的List集合，如何实现根据年龄排序？"></a>44.一个User的List集合，如何实现根据年龄排序？</h3><p>第一种方式，让User类实现Comparable接口，覆写compareTo方法，方法中自定义根据年龄比较的算法</p>
<p>第二种方式，调用Collections.sort方法，传入一个比较器，覆写compare方法，方法中自定义根据年龄比较的算法</p>
<h1 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h1><h3 id="1-项目开发流程"><a href="#1-项目开发流程" class="headerlink" title="1.项目开发流程"></a>1.项目开发流程</h3><p>项目启动</p>
<p>需求调研</p>
<p>系统设计</p>
<p>程序开发</p>
<p>测试</p>
<p>试用、培训、维护</p>
<h3 id="2-maven的打包和安装用什么命令"><a href="#2-maven的打包和安装用什么命令" class="headerlink" title="2.maven的打包和安装用什么命令"></a>2.maven的打包和安装用什么命令</h3><p>mvn compile 编译</p>
<p>mvn clean 清理</p>
<p>mvn test 测试</p>
<p>mvn package 打包</p>
<p>mvn install 打包并安装到本地仓库</p>
<h3 id="3-多表JOIN查询，完整查询SQL中的关键字的定义顺序"><a href="#3-多表JOIN查询，完整查询SQL中的关键字的定义顺序" class="headerlink" title="3.多表JOIN查询，完整查询SQL中的关键字的定义顺序"></a>3.多表JOIN查询，完整查询SQL中的关键字的定义顺序</h3><p>SELECT 列名 FROM 表1 JOIN  表2  ON  条件  WHERE 条件  GROUP BY  列名  HAVING  条件  ORDER BY  列名    LIMIT </p>
<h3 id="4-完整的多表JOIN查询，SQL中关键字的执行顺序"><a href="#4-完整的多表JOIN查询，SQL中关键字的执行顺序" class="headerlink" title="4.完整的多表JOIN查询，SQL中关键字的执行顺序"></a>4.完整的多表JOIN查询，SQL中关键字的执行顺序</h3><p>FROM  –&gt;  ON  –&gt;  JOIN  –&gt;  WHERE  –&gt;  GROUP BY  –&gt;  HAVING  –&gt;  ORDER BY  –&gt;  LIMIT</p>
<h3 id="5-MyBatis结果集映射，如果是单个关联对象用什么映射？如果是一个集合的查询用什么映射？"><a href="#5-MyBatis结果集映射，如果是单个关联对象用什么映射？如果是一个集合的查询用什么映射？" class="headerlink" title="5.MyBatis结果集映射，如果是单个关联对象用什么映射？如果是一个集合的查询用什么映射？"></a>5.MyBatis结果集映射，如果是单个关联对象用什么映射？如果是一个集合的查询用什么映射？</h3><p>单个关联对象用associate ，适用于多对一的关联查询，使用javaType来定义实体类型</p>
<p>集合用collection，适用于一对多的关联查询，使用ofType来定义集合的泛型类型</p>
<h3 id="6-MyBatis中-取值和-取值的区别"><a href="#6-MyBatis中-取值和-取值的区别" class="headerlink" title="6.MyBatis中${}取值和#{}取值的区别"></a>6.MyBatis中${}取值和#{}取值的区别</h3><p>#{}能够防止SQL注入，因为底层使用PreparedStatement对象，预编译，性能较高</p>
<p>${}不能防止SQL注入，因为底层使用Statement对象，不会预编译而是拼接字符串，性能较低</p>
<p>能使用#{}时尽量使用#{}，但如果直接在 SQL 语句中插入一个不改变的字符串。比如，像 ORDER BY时只能使用${}</p>
<h3 id="7-MyBatis关联查询中，延迟加载和饥饿加载的区别"><a href="#7-MyBatis关联查询中，延迟加载和饥饿加载的区别" class="headerlink" title="7.MyBatis关联查询中，延迟加载和饥饿加载的区别"></a>7.MyBatis关联查询中，延迟加载和饥饿加载的区别</h3><p>延迟加载，是先从单表查询，需要使用关联数据的时候才发起关联查询，不用的时候不查询关联的数据，又叫懒加载</p>
<p>饥饿加载，是在查询时将关联的数据立即查询出来加载进内存，不管用不用</p>
<h3 id="8-MyBatis一级缓存和二级缓存的区别"><a href="#8-MyBatis一级缓存和二级缓存的区别" class="headerlink" title="8.MyBatis一级缓存和二级缓存的区别"></a>8.MyBatis一级缓存和二级缓存的区别</h3><p>缓存，是指将从数据库查询出的数据存放在缓存中，下次使用相同查询时不必再从数据库查询，而是直接从缓存中读取，从而减轻数据库查询的压力，提高性能</p>
<p>mybaits中的一级缓存，是SqlSession级别，默认开启，使用同一个SqlSession发送相同的SQL时命中；它的生命周期和SqlSession一致，当调用SqlSession.close()方法时会释放缓存</p>
<p>mybatis中的二级缓存，是SqlSessionFactory级别，默认不开启，使用同一个SqlSessionFactory，发送相同的SQL时命中；它的生命周期是程序结束</p>
<p>当SQL中执行了update()、delete()、insert()操作，则缓存中的数据都会清空</p>
<h3 id="9-MyBaits的Mapper接口没有实现类为社么可以用-Autowired直接注入"><a href="#9-MyBaits的Mapper接口没有实现类为社么可以用-Autowired直接注入" class="headerlink" title="9.MyBaits的Mapper接口没有实现类为社么可以用@Autowired直接注入"></a>9.MyBaits的Mapper接口没有实现类为社么可以用@Autowired直接注入</h3><p>赋值给mapper接口引用的对象其实是一个代理对象，这个代理对象是由 JDK 动态代理创建的。在解析mapper的时候，mybatis会通过java反射，获取到接口所有的方法</p>
<p>当调用接口中方法时，将通过接口全限定名+方法名对应找到映射文件中namespace和id匹配的sql，然后将执行结果返回</p>
<h3 id="10-你对IOC的理解"><a href="#10-你对IOC的理解" class="headerlink" title="10.你对IOC的理解"></a>10.你对IOC的理解</h3><p>IOC，Inversion Of Control 英文首字母缩写，意为控制反转，是Spring的核心思想之一</p>
<p>控制，指的是对向创建、实例化、管理、销毁等等权力</p>
<p>反转，指的是将控制权交给Spring框架，IOC容器</p>
<p>使用依赖注入的方式，将需要的外部资源注入到组件中，使用IOC使得对象之间的耦合度降低，资源变得容易管理，从而使得代码更加优雅</p>
<h3 id="11-你对AOP的理解，AOP的使用场景是什么？实现原理是什么？"><a href="#11-你对AOP的理解，AOP的使用场景是什么？实现原理是什么？" class="headerlink" title="11.你对AOP的理解，AOP的使用场景是什么？实现原理是什么？"></a>11.你对AOP的理解，AOP的使用场景是什么？实现原理是什么？</h3><p>AOP，Aspect Oriented Programming 英文首字母缩写，意为面向切面编程，是Spring的核心思想之一</p>
<p>AOP是对OOP(面向对象编程)的一种补充，能够做到很多面向对象无法做到的事情，比如需要在所有方法执行前开启事务，打印日志，如果使用面向对象来编程，将会产生大量重复代码，而使用AOP，可以将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，一次解决这些问题。而这些重复的代码，一般统称为横切逻辑代码</p>
<p>使用AOP，在不改变原有业务逻辑的情况下，实现解耦合，避免横切逻辑代码重复</p>
<p>AOP的使用场景包括日志记录，性能统计，安全控制，事务处理，异常处理等等</p>
<p>它是基于动态代理实现的，分为JDK动态代理和CGLIB动态代理。JDK动态代理只支持实现了接口的类 ，CGLIB支持没有实现接口的类。Spring默认使用JDK动态代理，如果被代理类没有实现接口，会选择CGLIB动态代理</p>
<h3 id="12-说一下切面相关的注解，分别是什么意思"><a href="#12-说一下切面相关的注解，分别是什么意思" class="headerlink" title="12.说一下切面相关的注解，分别是什么意思"></a>12.说一下切面相关的注解，分别是什么意思</h3><p>@Aspect：定义切面</p>
<p>@Pointcut：定义切点</p>
<p>@Before：前置通知，在目标方法运行之前运行</p>
<p>@After：后置通知，在目标方法运行结束之后运行（无论方法正常结束还是异常结束）</p>
<p>@AfterReturning：返回通知，在目标方法正常返回之后运行</p>
<p>@AfterThrowing：异常通知，在目标方法出现异常以后运行</p>
<p>@Around：动态代理，手动推进目标方法运行</p>
<h3 id="13-Bean的四种注册方式"><a href="#13-Bean的四种注册方式" class="headerlink" title="13.Bean的四种注册方式"></a>13.Bean的四种注册方式</h3><p>方式一：普通注册方式，直接通过class注册</p>
<p>方式二：简单静态工厂方式注册</p>
<p>方式三：简单实例工厂方式注册</p>
<p>方式四：FactoryBean方式注册</p>
<h3 id="14-注册Bean的注解有哪些"><a href="#14-注册Bean的注解有哪些" class="headerlink" title="14.注册Bean的注解有哪些"></a>14.注册Bean的注解有哪些</h3><p>@Controller/@RestController 一般用于定义控制层的类</p>
<p>@Service    一般用于定义服务层的类</p>
<p>@Repository    一般用于定义持久层类</p>
<p>@Component    定义一般类</p>
<p>@Configuration 定义配置类</p>
<h3 id="15-SpringBoot和Spring有什么区别"><a href="#15-SpringBoot和Spring有什么区别" class="headerlink" title="15.SpringBoot和Spring有什么区别"></a>15.SpringBoot和Spring有什么区别</h3><p>Springboot是一个基于spring的框架，对spring做了大量简化，使开发流程更快，更高效</p>
<p>它大量简化maven依赖，管理了大量的基础依赖</p>
<p>基于注解配置（JavaConfig），无需xml配置</p>
<p>内嵌Tomcat，部署流程简单</p>
<p>打包和部署更加灵活，允许独立运行</p>
<h3 id="16-SpringBootApplication注解的含义"><a href="#16-SpringBootApplication注解的含义" class="headerlink" title="16.@SpringBootApplication注解的含义"></a>16.@SpringBootApplication注解的含义</h3><p>@SpringBootApplication是SprnigBoot项目的核心注解，目的是开启自动配置，并表示该类为主启动类。它包含三个子标签</p>
<p>​        @ComponentScan注解：开启ioc自动扫描注解，默认扫描当前包及其子包中@Controller,@Service等，并把这些bean加载到ioc器中</p>
<p>​        @EnableAutoConfiguration注解：启用springboot自动配置，自动所有扫描classpath目录下面所有jar中的spring.factories文件实现配置类批量注册</p>
<p>​        @SpringBootConfiguration注解：标志该类为springboot配置类</p>
<h3 id="17-spring-boot-starter-parent的作用"><a href="#17-spring-boot-starter-parent的作用" class="headerlink" title="17.spring-boot-starter-parent的作用"></a>17.spring-boot-starter-parent的作用</h3><p>这是SpringBoot的父工程，它的作用是帮我们管理了很多的基础jar包，同时它继承了spring-boot-dependencies，在spring-boot-        dependencies项目中通过<dependencyManagement>管理了大量的依赖，同时通过<properties>维护了这些依赖的版本号</p>
<p>但是在项目中，还需要通过<dependencies> 去导入具体的依赖才能使用</p>
<h3 id="18-spring-boot-starter-web的作用"><a href="#18-spring-boot-starter-web的作用" class="headerlink" title="18.spring-boot-starter-web的作用"></a>18.spring-boot-starter-web的作用</h3><p>此项目是Springboot和Springmvc整个的jar包，构建了web项目的基本环境，集成了日志，tomcat，springmvc，json支持等等</p>
<h3 id="19-SpringBoot中如何读取配置"><a href="#19-SpringBoot中如何读取配置" class="headerlink" title="19.SpringBoot中如何读取配置"></a>19.SpringBoot中如何读取配置</h3><p>方式一：使用@Value读取配置文件</p>
<p>方式二：使用@ConfigurationProperties读取配置文件</p>
<h3 id="20-SpringBoot中日志的level有哪些"><a href="#20-SpringBoot中日志的level有哪些" class="headerlink" title="20.SpringBoot中日志的level有哪些"></a>20.SpringBoot中日志的level有哪些</h3><p>日志级别从低到高分别为：</p>
<p>TRACE &lt; DEBUG &lt;INFO &lt;WARN &lt; ERROR</p>
<p>如果设置为 WARN，则低于 WARN 的信息都不会输出</p>
<p>Spring中默认使用INFO级别输出到控制台</p>
<h3 id="21-单例多例的区别"><a href="#21-单例多例的区别" class="headerlink" title="21.单例多例的区别"></a>21.单例多例的区别</h3><p>单例和多例属于对象模式，单例模式指对象在整个系统中只存在一份，多例模式则可以有多个实例。</p>
<p>在spring的ioc容器中的bean默认都是单例的，如果需要使用多例，可以通过修改scope属性：scope=”prototype”</p>
<p>如果一个bean是单例模式的，在处理多次请求的时候，在ioc容器中只实例化一个bean，这个对象会被保存在一个map中，当有请求来的时候，会先从map中查看，如果有就直接使用这个对象，没有才会实例化新的对象。</p>
<p>如果是多例(prototype)模式的bean，每次请求来的时候，会直接实例化新的bean，没有map缓存的过程。</p>
<h3 id="22-BeanFactory和ApplicationContext有什么区别"><a href="#22-BeanFactory和ApplicationContext有什么区别" class="headerlink" title="22.BeanFactory和ApplicationContext有什么区别"></a>22.BeanFactory和ApplicationContext有什么区别</h3><p>BeanFactory接口是IOC容器的核心接口，定义了管理bean的最基本方法，比如实例化，配置，管理，获取bean的方法</p>
<p>ApplicationContext接口是BeanFactory接口的子接口，除了继承BeanFactory中所有管理bean的方法，还拥有环境、国际化、资源、事件等服务相关的接口</p>
<p>BeanFactory是延迟加载，ApplicationContext是迫切加载</p>
<h3 id="23-BeanFactory和FactoryBean的区别"><a href="#23-BeanFactory和FactoryBean的区别" class="headerlink" title="23.BeanFactory和FactoryBean的区别"></a>23.BeanFactory和FactoryBean的区别</h3><p>BeanFactory接口是IOC容器的核心接口，定义了管理bean的最基本方法，比如实例化，配置，管理，获取bean的方法</p>
<p>FactoryBean是IOC容器创建bean的一种形式，可以通过实现此接口来创建实例化过程比较复杂的bean</p>
<h3 id="24-介绍一下Spring框架的组成"><a href="#24-介绍一下Spring框架的组成" class="headerlink" title="24.介绍一下Spring框架的组成"></a>24.介绍一下Spring框架的组成</h3><ol>
<li>CoreContain核心容器模块：<ol>
<li>spring-core：提供框架的基本组成部分，包括 IoC 和依赖注入功能</li>
<li>spring-beans：提供 BeanFactory，工厂模式</li>
<li>context：提供国际化，事件传播，资源加载等功能</li>
<li>spring-ExpressionLanguage：提供表达式语言</li>
</ol>
</li>
<li>Web模块<ol>
<li>Web：提供面向web的基本功能和面向web的应用上下文</li>
<li>Web-MVC：为web应用提供模型视图控制（MVC）</li>
<li>Web-Socket：在 web 应用程序中提供客户端和服务器端之间通信的方式</li>
<li>Web-Portlet：模块提供了用于Portlet环境的MVC实现</li>
</ol>
</li>
<li>数据/集成模块<ol>
<li>JDBC：包含了Spring对JDBC数据访问进行封装的所有类</li>
<li>ORM：为对象-关系映射提供交互层</li>
<li>OXM：提供对Object/XML映射实现的抽象层</li>
<li>JMS：主要包含了一些制造、消费和消息的功能</li>
<li>Transaction：为实现特殊接口类以及所有的 POJO 支持编程式和声明式的事务管理</li>
</ol>
</li>
<li>其他模块<ol>
<li>AOP：提供了面向切面编程相关实现</li>
<li>Aspects：模块提供了与AspectJ的集成，是一个功能强大的AOP框架</li>
<li>Instrumentation：提供了class instrumentation 的支持和类加载器classloader的实现</li>
<li>Messaging：为 STOMP 提供支持</li>
<li>Test：支持使用JUnit和TestNG对Spring组件进行测试</li>
</ol>
</li>
</ol>
<h3 id="25-Spring的Bean懒加载和非懒加载有什么区别"><a href="#25-Spring的Bean懒加载和非懒加载有什么区别" class="headerlink" title="25.Spring的Bean懒加载和非懒加载有什么区别"></a>25.Spring的Bean懒加载和非懒加载有什么区别</h3><p>懒加载：需要使用对象的时候才创建，节省资源，但不利于提前发现错误</p>
<p>非懒加载，也叫迫切加载，容器启动时就创建对象，消耗资源，但有利于提前发现错误</p>
<p>spring中默认时迫切加载，即在项目启动时，spring会扫描符合条件的所有bean并将其初始化</p>
<p>如果需要懒加载，可以使用@Lazy注释或者xml中配置属性default-lazy-init=”true”</p>
<h3 id="26-Spring的依赖注入方式有哪些？"><a href="#26-Spring的依赖注入方式有哪些？" class="headerlink" title="26.Spring的依赖注入方式有哪些？"></a>26.Spring的依赖注入方式有哪些？</h3><p>方式一：setter方式注入，通过反射调用无参构造方法生成对象，再通过对于的setter方法注入配置的值，支持注解和xml两种实现方式</p>
<p>方式二：构造器方式注入，通过反射调用有参构造方法生成对象，支持注解和xml两种实现方式</p>
<p>注解实现方式：@Autowired，它是默认按类型匹配的、@Resource，它是默认按名字匹配的</p>
<h3 id="27-SpringBoot中如何管理事务-？"><a href="#27-SpringBoot中如何管理事务-？" class="headerlink" title="27.SpringBoot中如何管理事务 ？"></a>27.SpringBoot中如何管理事务 ？</h3><p>事务(transaction)是指业务逻辑上对数据库进行的一系列持久化操作，要么全部成功，要么全部失败。</p>
<p>在Springboot中，可以通过xml配置和注解配置</p>
<p>xml方式通过配置DataSourceTransactionManager和transactionManager实现</p>
<p>注解方式配置通过在主启动类上加上@EnableTransactionManagement开启事务管理器，在具体的实现层service类上加上@Transactional 实现事务</p>
<h3 id="28-什么是RBAC-，-相关表怎么设计的？"><a href="#28-什么是RBAC-，-相关表怎么设计的？" class="headerlink" title="28.什么是RBAC ， 相关表怎么设计的？"></a>28.什么是RBAC ， 相关表怎么设计的？</h3><p>RBAC：Role-Based Access Control首字母缩写，意为基于角色的访问控制。基本思想是对系统操作的各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。</p>
<p>将权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。</p>
<p>实现RBAC，需要将用户对权限的多对多关系，转化为用户对角色，角色对权限的多对多关系，因此在数据库中，需要在用户，角色，权限中分别加入中间表，即用户表，用户和角色关系表，角色表，角色和权限关系表，权限表</p>
<h3 id="29-在VUE中，什么是MVVM"><a href="#29-在VUE中，什么是MVVM" class="headerlink" title="29.在VUE中，什么是MVVM"></a>29.在VUE中，什么是MVVM</h3><p>MVVM，Model–View–ViewModel首字母缩写，是一种软件架构模式。</p>
<p>其中Model指的是模型，包括数据和一些基本操作</p>
<p>View指的是视图，页面渲染结果</p>
<p>ViewModel指的是模型与视图间的双向操作</p>
<p>MVVM的思想就是数据模型和视图的双向绑定，只要数据变化，视图会跟着变化，只要视图被修改，数据也会跟者变化</p>
<h3 id="30-讲几个VUE的指令"><a href="#30-讲几个VUE的指令" class="headerlink" title="30.讲几个VUE的指令"></a>30.讲几个VUE的指令</h3><p>v-text：给元素填充纯文本内容</p>
<p>v-html：给元素填充内容，与v-text的区别是它会把内容的html符号进行渲染</p>
<p>v-for：遍历数字，字符串，数组，对象</p>
<p>v-bind：将data中的数据绑定到标签上,作为标签的属性</p>
<p>v-model：创建双向绑定，表单的值被修改时会自动修改data中的数据，data中的值变化时页面也会被修改</p>
<p>v-show：根据表达式的真假值，切换元素的css属性</p>
<p>v-if：根据表达式的真假值，销毁或重建元素</p>
<p>v-on：绑定事件</p>
<h3 id="31-Node你们用的哪个版本，vue你们用的哪个版本，npm你们用的哪个版本"><a href="#31-Node你们用的哪个版本，vue你们用的哪个版本，npm你们用的哪个版本" class="headerlink" title="31.Node你们用的哪个版本，vue你们用的哪个版本，npm你们用的哪个版本"></a>31.Node你们用的哪个版本，vue你们用的哪个版本，npm你们用的哪个版本</h3><p>nodejs版本：v10.16.0</p>
<p>vue版本：2.6.13</p>
<p>npm版本：6.9.0</p>
<h3 id="32-webpack的作用"><a href="#32-webpack的作用" class="headerlink" title="32.webpack的作用"></a>32.webpack的作用</h3><p>​    首先，它可以将ES6等高级语法，编译成各个浏览器都认识的语法</p>
<p>​    其次，它可以将相互依赖的许多散碎文件搞成一个整体，提高网页访问的效率</p>
<p>​    再次，它可以将代码压缩，减小代码体积</p>
<h3 id="33-Vue中定义组件分为几种，有什么区别"><a href="#33-Vue中定义组件分为几种，有什么区别" class="headerlink" title="33.Vue中定义组件分为几种，有什么区别"></a>33.Vue中定义组件分为几种，有什么区别</h3><p>组件是一种自定义的元素标签，可以对功能封装，提高代码复用性，分为全局组件和局部组件两种</p>
<p>​    全局组件，是在所有vue挂载的标签中都有效，</p>
<p>​    局部组件，只在当前vue所挂载的标签中有效</p>
<h3 id="34-前后端分离的好处"><a href="#34-前后端分离的好处" class="headerlink" title="34.前后端分离的好处"></a>34.前后端分离的好处</h3><p>第一，专人干专事，前后端同时开发，效率更高</p>
<p>第二，责任分离，避免了前后端相互踢皮球的现象</p>
<p>第三，前后端解耦合，一套后端可以处理不同的前端，包括app端，浏览器端</p>
<p>第四，分开部署，减轻了服务器压力</p>
<p>第五，页面显示东西再多也不怕，数据都是异步加载，就算后端服务器挂了，前端页面也能访问，虽然没有数据</p>
<h3 id="35-你们这个前后端分离项目是怎么部署的"><a href="#35-你们这个前后端分离项目是怎么部署的" class="headerlink" title="35.你们这个前后端分离项目是怎么部署的"></a>35.你们这个前后端分离项目是怎么部署的</h3><p>前后端分开部署，前端使用Nginx部署，</p>
<p>后端使用Springboot内嵌的tomcat部署，</p>
<p>分开部署后，通过代理解决前后端域名不一致的跨域问题</p>
<h3 id="36-你们这个前后端分离项目的技术栈是怎么样的"><a href="#36-你们这个前后端分离项目的技术栈是怎么样的" class="headerlink" title="36.你们这个前后端分离项目的技术栈是怎么样的"></a>36.你们这个前后端分离项目的技术栈是怎么样的</h3><p>前端门户系统：HTML + JQuery + CSS</p>
<p>前端管理系统：VUE + ElementUI</p>
<p>后端系统：基于SpringBoot框架的SpringMVC + MyBatis + Redis</p>
<h3 id="37-讲一下你用过ElementUI的哪些组件"><a href="#37-讲一下你用过ElementUI的哪些组件" class="headerlink" title="37.讲一下你用过ElementUI的哪些组件"></a>37.讲一下你用过ElementUI的哪些组件</h3><p>基础组件，比如按钮Button，图标Icon</p>
<p>表单组件：比如表单Form，单选框Radio，多选框Checkbox，输入框Input，选择器Select，级联选择器Cascader</p>
<p>其他组件：比如Dialog对话框，消息提示Message</p>
<h3 id="38-你们用什么做项目代码管理的"><a href="#38-你们用什么做项目代码管理的" class="headerlink" title="38.你们用什么做项目代码管理的"></a>38.你们用什么做项目代码管理的</h3><p>使用主流的Git管理项目</p>
<h3 id="39-讲讲Git相对于SVN的区别"><a href="#39-讲讲Git相对于SVN的区别" class="headerlink" title="39.讲讲Git相对于SVN的区别"></a>39.讲讲Git相对于SVN的区别</h3><p>第一。Git是每个攻城狮都有自己的版本库，可以在自己的库上任意操作提交代码</p>
<p>第二。Git在每个工程只产生一个.git目录，而SVN会在每个目录下都生成.svn目录</p>
<p>第三。Git能快速切换分支，且合并文件的速度比SVN快</p>
<p>第四。Git采用分布式版本库，内容完整性更好</p>
<h3 id="40-讲几个Git的命令"><a href="#40-讲几个Git的命令" class="headerlink" title="40.讲几个Git的命令"></a>40.讲几个Git的命令</h3><p>​    git clone：从远程仓库克隆项目到本地</p>
<p>​    git add：添加代码到本地仓库管理</p>
<p>​    git commit：提交add后的代码到本地仓库</p>
<p>​    git push：推送本地仓库文件到远程仓库</p>
<p>​    git pull：拉取远程仓库中的代码到本地仓库</p>
<h3 id="41-讲一下你理解的Redis，为什么Redis很快"><a href="#41-讲一下你理解的Redis，为什么Redis很快" class="headerlink" title="41.讲一下你理解的Redis，为什么Redis很快"></a>41.讲一下你理解的Redis，为什么Redis很快</h3><p>Redis是一种高性能的，开源的，C语言编写的非关系型数据库，可以对关系型数据库起到补充作用，同时支持持久化，可以将数据同步保存到磁盘</p>
<p>说Redis很快是相对于关系型数据库如mysql来说的，主要有以下因素</p>
<p>​    第一，数据结构简单，所以速度快</p>
<p>​    第二，直接在内存中读写数据，所以速度快</p>
<p>​    第三，采用多路IO复用模型，减少网络IO的时间消耗，避免大量的无用操作，所以速度快</p>
<p>​    第四，单线程避免了线程切换和上下文切换产生的消耗，所以速度快</p>
<h3 id="42-你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么"><a href="#42-你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么" class="headerlink" title="42.你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么"></a>42.你常用的Redis的数据存储结构有哪些，他们的使用场景分别是什么</h3><p>Redis存储形式是键值对，支持value形式包括String，List，Set，ZSet，Hash。</p>
<p>String可以用作缓存，计数器，防攻击，验证码、登录过期等，List可以用来做队列，秒杀等，Set可以用来去重</p>
<h3 id="43-每种存储结构说-4-个命令吧"><a href="#43-每种存储结构说-4-个命令吧" class="headerlink" title="43.每种存储结构说 4 个命令吧"></a>43.每种存储结构说 4 个命令吧</h3><p>1.String</p>
<p>​    set key value    设置值</p>
<p>​    get key               取值</p>
<p>​    mset key value key value…    设置多个值</p>
<p>​    mget key key    获取多个值</p>
<p>​    incr key    将key中的值自增1</p>
<p>​    decre key    将key中的值自减1</p>
<p>2.List</p>
<p>​    lpush key value value…    从最左边设置值</p>
<p>​    rpush key value value…    从最右边设置值</p>
<p>​    lrange key start stop    查询key中指定区间的元素</p>
<p>​    lpop key    移出并返回key中最左边的元素</p>
<p>​    rpop key    移出并返回key中最右边的元素</p>
<p>3.Set</p>
<p>​    sadd key value value    添加元素</p>
<p>​    smembers key    返回集合key中的所有元素</p>
<p>​    srem key member    删除集合key中member元素</p>
<p>​    scard key    查询集合key中的元素数量</p>
<p>4.ZSet</p>
<p>​    zadd key score value (score value)…    添加元素</p>
<p>​    zcard key    查询集合key中元素数量</p>
<p>​    zcount key min max    返回有序集合key中score 在min和max之间的元素</p>
<p>​    zrange key start stop    返回有序集合key中索引在start和stop之间的元素</p>
<p>5.Hash</p>
<p>​    hset key field value    添加元素</p>
<p>​    hget key field    获取key集合中field键对应的值</p>
<p>​    hmset key field value (field value)…    添加元素并批量添加子键值对</p>
<p>​    hmget key field field    获取key集合中所有的子键值对</p>
<p>​    </p>
<h3 id="44-你们项目是怎么用Redis的？"><a href="#44-你们项目是怎么用Redis的？" class="headerlink" title="44.你们项目是怎么用Redis的？"></a>44.你们项目是怎么用Redis的？</h3><p>使用的是Springboot整合的redis，主要用来解决前后端分离后前后端会话问题，以及验证码的问题</p>
<h3 id="45-怎么防止Redis宕机数据丢失问题"><a href="#45-怎么防止Redis宕机数据丢失问题" class="headerlink" title="45.怎么防止Redis宕机数据丢失问题"></a>45.怎么防止Redis宕机数据丢失问题</h3><p>通过对Redis持久化，把内存中的数据和命令，保存一份到磁盘中做备份，当Redis发生宕机，重启服务器的时候，会从磁盘重新加载备份的数据，从而解决数据丢失问题</p>
<h3 id="46-Redis持久化是什么？有几种方式"><a href="#46-Redis持久化是什么？有几种方式" class="headerlink" title="46.Redis持久化是什么？有几种方式"></a>46.Redis持久化是什么？有几种方式</h3><p>将内存中的数据备份到磁盘的过程，就叫作持久化</p>
<p>Redis持久化主要有两种方式，RDB和AOF，可以通过修改redis.conf进行配置</p>
<p>RDB是记录数据快照，而AOF是记录写命令的</p>
<h3 id="47-Redis有了AOF持久化为什么还要RDB？"><a href="#47-Redis有了AOF持久化为什么还要RDB？" class="headerlink" title="47.Redis有了AOF持久化为什么还要RDB？"></a>47.Redis有了AOF持久化为什么还要RDB？</h3><p>AOF和RDB各有所长</p>
<p>​    RDB是记录数据快照，它的优点是只产生一个持久化文件，体积相对较小，启动恢复速度快，备份方便，它的缺点是没办法做到数据百分百不丢失，因为它是每隔一定时间保存一次</p>
<p>​    AOF是记录写命令，它的优点是格式清晰，容易理解，数据更安全，采用append模式即使持久化过程中宕机，也不影响已经保存的数据，它的缺点是文件体积较大，恢复速度慢</p>
<p>根据实际需要来选择，通常二者可以结合来使用</p>
<p>​    </p>
<h3 id="48-Redis内存不够了怎么办？"><a href="#48-Redis内存不够了怎么办？" class="headerlink" title="48.Redis内存不够了怎么办？"></a>48.Redis内存不够了怎么办？</h3><p>方式一：增加物理内存</p>
<p>方式二：使用淘汰策略，删掉一些老旧数据</p>
<h3 id="49-淘汰策略有哪些？你们用的哪种"><a href="#49-淘汰策略有哪些？你们用的哪种" class="headerlink" title="49.淘汰策略有哪些？你们用的哪种"></a>49.淘汰策略有哪些？你们用的哪种</h3><p>​    volatile-lru ：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</p>
<p>​    volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</p>
<p>​    volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</p>
<p>★ allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</p>
<p>​    allkeys-random：从数据集中任意选择数据淘汰</p>
<p>​    no-enviction：不使用淘汰</p>
<h3 id="50-Redis事务和Mysql事务的区别"><a href="#50-Redis事务和Mysql事务的区别" class="headerlink" title="50.Redis事务和Mysql事务的区别"></a>50.Redis事务和Mysql事务的区别</h3><p>Mysql的事务是基于日志，记录修改数据前后的状态来实现的，而Redis的事务是基于队列实现的</p>
<p>Mysql中的事务满足原子性：即一组操作要么同时成功，要么同时失败，</p>
<p>Redis中的事务不满足原子性，即一组操作中某些命令执行失败了，其他操作不会回滚</p>
<p>因此对于比较重要的数据，应该存放在mysql中</p>
<h3 id="51-使用Redis如何实现消息广播"><a href="#51-使用Redis如何实现消息广播" class="headerlink" title="51.使用Redis如何实现消息广播"></a>51.使用Redis如何实现消息广播</h3><p>Redis是使用发布订阅来实现广播的</p>
<p>订阅者通过 SUBSCRIBE channel命令订阅某个频道 ， 发布者通过 PUBLISH channel message向该频道发布消息，该频道的所有订阅者都可以收到消息</p>
<h3 id="52-讲一下你们宠物这个项目中店铺的入驻流程"><a href="#52-讲一下你们宠物这个项目中店铺的入驻流程" class="headerlink" title="52.讲一下你们宠物这个项目中店铺的入驻流程"></a>52.讲一下你们宠物这个项目中店铺的入驻流程</h3><p>首先店铺需进行注册，将店铺的信息和管理员账号信息分别保存</p>
<p>然后平台对店铺进行审核，如果审核通过，发送激活邮件，店铺在有效期内点击邮件中的链接进行激活，此时店铺就可以正常登录</p>
<p>如果审核失败，也会发送驳回信息的邮件，店铺需重新申请</p>
<h3 id="53-如果有人用脚本刷你们的短信接口怎么办？"><a href="#53-如果有人用脚本刷你们的短信接口怎么办？" class="headerlink" title="53.如果有人用脚本刷你们的短信接口怎么办？"></a>53.如果有人用脚本刷你们的短信接口怎么办？</h3><p>首先，可以设置图形验证码，流量错峰</p>
<p>其次，可以获取请求的ip地址，手机号，发送时间，并保存到发送短信记录的日志中，对于短时间多次请求的ip地址，手机号，可以拦截不执行发送手机验证码</p>
<p>再次，可以设置单位时间内发送短信的总数量，比如设定1秒最多只发送10条验证码。但这种方式会降低并发性</p>
<h3 id="54-讲一下Session的工作原理"><a href="#54-讲一下Session的工作原理" class="headerlink" title="54.讲一下Session的工作原理"></a>54.讲一下Session的工作原理</h3><p>​    当用户端第一次发起请求时，服务器端保存session同时会生成一个sessionid</p>
<p>​    服务器将生成的sessionid返回给用户端</p>
<p>​    用户端收到sessionid并将sessionid保存在cookie中，此次会话的中所有对服务器端的访问，都会携带这个sessionid</p>
<p>​    服务端收到sessionid，就能找到对应的session数据</p>
<h3 id="55-讲一下你们的登录实现方案"><a href="#55-讲一下你们的登录实现方案" class="headerlink" title="55.讲一下你们的登录实现方案"></a>55.讲一下你们的登录实现方案</h3><p>​    当用户第一次发起登录请求，后台生成一个token保存到Redis中</p>
<p>​    将生成的token返回给用户端</p>
<p>​    用户端使用用浏览器中的localStorage保存token</p>
<p>​    通过axios的拦截器，给每次请求的请求头都加上token</p>
<p>​    服务端收到token，就能在Redis中找到对应的数据</p>
<h3 id="56-你们是怎么处理登录信息过期的？有什么更好方案吗？"><a href="#56-你们是怎么处理登录信息过期的？有什么更好方案吗？" class="headerlink" title="56.你们是怎么处理登录信息过期的？有什么更好方案吗？"></a>56.你们是怎么处理登录信息过期的？有什么更好方案吗？</h3><p>给保存在Redis中的token设置过期时间来处理登录过期的</p>
<p>为了防止已登录用户在访问后台时突然遭遇登录过期的情况，我们在后台接收到用户访问时，重新设置token的过期时间写入Redis，则用户访问期间就不会突然过期了</p>
<h3 id="57-你们Redis用在哪些业务上？用的什么存储结构？"><a href="#57-你们Redis用在哪些业务上？用的什么存储结构？" class="headerlink" title="57.你们Redis用在哪些业务上？用的什么存储结构？"></a>57.你们Redis用在哪些业务上？用的什么存储结构？</h3><p>主要用在校验验证码实现注册流程，保存token实现登录流程</p>
<p>都是使用String类型的存储结构，并且使用了Json格式进行序列化</p>
<h3 id="58-三方登录流程讲一下"><a href="#58-三方登录流程讲一下" class="headerlink" title="58.三方登录流程讲一下"></a>58.三方登录流程讲一下</h3><p>​    1.用户发起微信登录请求</p>
<p>​    2.后端获取请求二维码的连接，重定向到扫码界面</p>
<p>​    3.用户使用微信扫一扫并同意授权</p>
<p>​    4.后端回调获取授权码，并将授权码作为参数，重定向到前端跳转页面</p>
<p>​    5.前端将授权码返回后端，后端根据授权码获取token</p>
<p>​    6.后端根据token获取openId</p>
<p>​    7.根据openId查询微信用户表</p>
<p>​        如果查到有用户信息，且已关联本地账户，就默认登录</p>
<p>​        如果有查到用户信息，但没有关联本地账户，就跳转本地账户绑定页面，</p>
<p>​        如果没有查到用户信息，就向微信平台发起请求查询用户基本信息，添加到微信用户信息表，再跳转本地账户绑定页面</p>
<p>​    8.执行绑定逻辑时，根据手机号判断是否有本地账户，如果有就直接绑定，如果没有就自动注册再绑定，绑定成功后就默认登录</p>
<h3 id="59-Oauth2的优势"><a href="#59-Oauth2的优势" class="headerlink" title="59.Oauth2的优势"></a>59.Oauth2的优势</h3><p>oauth协议是一个安全的开放授权标准，</p>
<p>与传统的授权方式相比，它不会使第三方触及到用户的账号信息，比如用户名，密码。</p>
<h3 id="60-Oauth2的四种授权模式"><a href="#60-Oauth2的四种授权模式" class="headerlink" title="60.Oauth2的四种授权模式"></a>60.Oauth2的四种授权模式</h3><p>​    一、授权码模式，它是功能最完整，流程最严密的授权模式</p>
<p>​    二、简化模式，直接从前端渠道获取token，容易受安全攻击</p>
<p>​    三、用户名密码模式，使用用户名和密码登录的应用，比如桌面APP</p>
<p>​    四、客户端凭证模式，用户直接向客户端认证，客户端以自己的名义向第三方索取服务</p>
<h3 id="61-介绍一下寻主模块的业务流程"><a href="#61-介绍一下寻主模块的业务流程" class="headerlink" title="61.介绍一下寻主模块的业务流程"></a>61.介绍一下寻主模块的业务流程</h3><p>​    1.用户发起寻主需求，可以根据需要设定收购费用</p>
<p>​    2.后台进行寻主需求的审核，审核通过，自动匹配商家，匹配失败则进入寻主池，任意商家可接单</p>
<p>​    3.如果自动匹配商家，商家可以接单，也可以拒单，拒单后寻主需求会返回寻主池</p>
<p>​    4.商家如果接单了，可以分配给工作人员上门收购</p>
<p>​    5.工作人员上门收购，录入宠物信息到系统，选择支付方式，则完成收购，商家后续可以上架宠物进行销售</p>
<h3 id="62-讲一下宠物领养下单以及支付的总体流程"><a href="#62-讲一下宠物领养下单以及支付的总体流程" class="headerlink" title="62.讲一下宠物领养下单以及支付的总体流程"></a>62.讲一下宠物领养下单以及支付的总体流程</h3><p>​    1.商家上架宠物，门户网站可以浏览到所有上架的宠物列表</p>
<p>​    2.点击宠物进入详情页面，可以直接购买</p>
<p>​    3.用户点击购买，发出下单申请，需要选择收货地址和支付方式</p>
<p>​    4.确定订单后，后台保存领养订单包括对应的地址，以及一个支付账单</p>
<h3 id="63-讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？"><a href="#63-讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？" class="headerlink" title="63.讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？"></a>63.讲一下什么是非对称加密，什么是数字签名，数字签名的作用是什么？</h3><p>非对称加密是一种算法，指的是加密和解密时使用不同的密钥，其中私钥不可公开，公钥可以公开。</p>
<p>数字签名就是在非对称加密的基础上，使用私钥加密，公钥解密，主要用来防止数据被篡改，实现安全传输的目的</p>
<h3 id="64-你们项目中有哪些订单？"><a href="#64-你们项目中有哪些订单？" class="headerlink" title="64.你们项目中有哪些订单？"></a>64.你们项目中有哪些订单？</h3><p>​    1.账户充值，提现订单，通过银行或其他支付平台向用户账户充值，或从用户账户中取出到银行卡中</p>
<p>​    2.寻主收购订单，商家支付费用给宠物主任</p>
<p>​    3.宠物服务订单，比如宠物洗澡，宠物按摩的服务费用</p>
<p>​    4.宠物领养订单，用户在平台购买宠物</p>
<p>​    5.宠物商品订单，比如狗粮，猫砂等支付订单</p>
<h3 id="65-要求每天早上-1点统计前一天的平台注册人数，怎么做？"><a href="#65-要求每天早上-1点统计前一天的平台注册人数，怎么做？" class="headerlink" title="65.要求每天早上 1点统计前一天的平台注册人数，怎么做？"></a>65.要求每天早上 1点统计前一天的平台注册人数，怎么做？</h3><p>​    首先，可以将每天平台的注册信息以Zset结构存放到Redis中，将注册时间作为score</p>
<p>​    然后，使用quartz定时器制定任务，使用zcount命令统计score值在指定范围内的人数</p>
<h3 id="66-使用定时任务做订单超时关单，那并发多的时候不就会产生很多的定时任务吗？性能不会很差吗？你怎么优化"><a href="#66-使用定时任务做订单超时关单，那并发多的时候不就会产生很多的定时任务吗？性能不会很差吗？你怎么优化" class="headerlink" title="66.使用定时任务做订单超时关单，那并发多的时候不就会产生很多的定时任务吗？性能不会很差吗？你怎么优化"></a>66.使用定时任务做订单超时关单，那并发多的时候不就会产生很多的定时任务吗？性能不会很差吗？你怎么优化</h3><p>对于我们的小型项目，并发在1000以下可以使用quartz定时器，使用起来也很简单方便</p>
<p>但如果是高并发，比如秒杀等业务，可以使用RabbitMQ的延迟队列来实现，也可以使用Redis监听key过期事件来处理</p>
<h3 id="67-讲一下你做过的比较复杂的业务，或者遇到过的比较难的问题。你是如何解决的？"><a href="#67-讲一下你做过的比较复杂的业务，或者遇到过的比较难的问题。你是如何解决的？" class="headerlink" title="67.讲一下你做过的比较复杂的业务，或者遇到过的比较难的问题。你是如何解决的？"></a>67.讲一下你做过的比较复杂的业务，或者遇到过的比较难的问题。你是如何解决的？</h3><p>比如说使用微信作为第三方登录，公司之前是只使用了本地账户管理，所有新客户都需要注册而填一大堆注册信息</p>
<p>​        后来我有幸接手并重新设计了这个模块，采用了时下最流行的第三方登录，考虑到微信用户量庞大，能快速引流，新客户也只需要扫码就能快速注册并登录，因此我最终选择了微信登录。</p>
<p>​        当时我也大量查询了网上各种方案，结合微信开放平台的API，确定了最终的方案。也就是通过在数据库维护了微信用户表，同时关联一个本地账户表来实现，最终的实现效果也很理想</p>
<h3 id="68-说说preparedStatement和Statement的区别"><a href="#68-说说preparedStatement和Statement的区别" class="headerlink" title="68.说说preparedStatement和Statement的区别"></a>68.说说preparedStatement和Statement的区别</h3><p>statement的sql语句使用字符串拼接，很容易出错，而preparedStatement使用？作为占位符，不容易出错易于维护</p>
<p>statement不对sql语句作处理，直接交给数据库，而preparedStatement支持预编译，事先将编译好的sql语句放到数据库端，相当于缓存，因此效率更高</p>
<p>statement有sql注入风险，preparedStatement没有sql注入风险</p>
<h3 id="69-为什么要使用连接池，数据库连接池的原理"><a href="#69-为什么要使用连接池，数据库连接池的原理" class="headerlink" title="69.为什么要使用连接池，数据库连接池的原理"></a>69.为什么要使用连接池，数据库连接池的原理</h3><p>对数据库的操作都需要取得连接，使用完都需要关闭连接，如果每次操作需要打开关闭连接，这样系统性能很低下。连接池就可以动态的管理这些连接的申请，使用和释放，我们操作数据库只需要在连接池里获取连接，使用完放回连接池，这样大大节省了内存，提高效率。</p>
<p>数据库连接池的原理主要分为三部分</p>
<p>​        第一，连接池的建立，在系统初始化时建立几个连接对象以便使用。</p>
<p>​        第二，连接池的管理，客户请求连接数据库时，首先查看连接池中是否有空闲连接，如果有直接分配，如果没有就等待，直到超出最大等待时间，抛出异常</p>
<p>​        第三，连接池的关闭，当系统关闭时，连接池中所有连接关闭</p>
<h3 id="70-Session和cookie有什么区别"><a href="#70-Session和cookie有什么区别" class="headerlink" title="70.Session和cookie有什么区别"></a>70.Session和cookie有什么区别</h3><p>session和cookie都是为了弥补http协议的无状态特性，解决会话问题</p>
<p>session是以ConcurrentHashMap结构存储在服务器端，同时生成一个sessionid返回客户端并存放到cookie中</p>
<p>cookie是将数据存储在客户浏览器端</p>
<p>session占用服务器的性能，但安全性较高，使用cookie减轻服务器的压力，但有被用户篡改风险因此安全性较低</p>
<h3 id="71-请求转发和重定向的区别？"><a href="#71-请求转发和重定向的区别？" class="headerlink" title="71.请求转发和重定向的区别？"></a>71.请求转发和重定向的区别？</h3><p>​    转发是一次请求，可以共享同一组request和response，重定向是多次请求，不能共享同一组request和response</p>
<p>​    转发地址栏不会发生变化，重定向地址栏会发生变化</p>
<p>​    转发不能到外部应用，重定向可以到尾部应用</p>
<p>​    如果我们需要数据共享，使用转发，如果需要访问内部资源(WEB-INF)，使用转发，如果需要跨域到外部资源，必须使用重定向</p>
<h3 id="72-get和post请求的区别"><a href="#72-get和post请求的区别" class="headerlink" title="72.get和post请求的区别"></a>72.get和post请求的区别</h3><p>最直观的区别，get把参数包含在url中，post是把参数放到request body中</p>
<p>post相对于get更安全</p>
<p>post发送的数据更大，get有url的长度限制</p>
<p>post更发送更多的数据类型，get只能发送ASCII字符</p>
<p>在restful中，get一般用户查询搜索数据，post一般用户添加或者修改数据</p>
<h3 id="73-JSP的原理"><a href="#73-JSP的原理" class="headerlink" title="73.JSP的原理"></a>73.JSP的原理</h3><p>jsp的本质就是servlet，静态部分是标准的html，动态部分是java程序</p>
<h3 id="74-Mybatis的Mapper接口为什么可以-Autowire直接注入"><a href="#74-Mybatis的Mapper接口为什么可以-Autowire直接注入" class="headerlink" title="74.Mybatis的Mapper接口为什么可以@Autowire直接注入"></a>74.Mybatis的Mapper接口为什么可以@Autowire直接注入</h3><p>赋值给mapper接口引用的对象其实是一个代理对象，这个代理对象是由 JDK 动态代理创建的。在解析mapper的时候，mybatis会通过java反射，获取到接口所有的方法</p>
<p>当调用接口中方法时，将通过接口全限定名+方法名对应找到映射文件中namespace和id匹配的sql，然后将执行结果返回</p>
<h3 id="75-在MyBatis如何动态修改SQL（在代码执行的过程中修改SQL）"><a href="#75-在MyBatis如何动态修改SQL（在代码执行的过程中修改SQL）" class="headerlink" title="75.在MyBatis如何动态修改SQL（在代码执行的过程中修改SQL）"></a>75.在MyBatis如何动态修改SQL（在代码执行的过程中修改SQL）</h3><p>使用Mybatis的拦截器可以做到 </p>
<h3 id="76-MyBatis的动态SQL标签有哪些？"><a href="#76-MyBatis的动态SQL标签有哪些？" class="headerlink" title="76.MyBatis的动态SQL标签有哪些？"></a>76.MyBatis的动态SQL标签有哪些？</h3><p>if标签：条件判断</p>
<p>choose、when、otherwise标签：选择结构，类似java中的switch</p>
<p>trim标签：对包含的内容加上前缀，后缀</p>
<p>where标签：主要是用来简化SQL语句中where条件判断的，能智能的处理and or，不必担心多余导致语法错误</p>
<p>foreach标签：遍历元素</p>
<h3 id="77-Mybatis的mapper如何传递多个参数"><a href="#77-Mybatis的mapper如何传递多个参数" class="headerlink" title="77.Mybatis的mapper如何传递多个参数?"></a>77.Mybatis的mapper如何传递多个参数?</h3><p>方式一，可以使用map进行传参，SQL中使用map的key来引用取值</p>
<p>方式二，可以在SQL中使用#{param1}，#{param2}…来引用取值，它是根据mapper接口对应方法中形参的顺序进行匹配的，不管接口方法的参数名字叫个啥，SQL都只能使用param1，param2，等来取值</p>
<p>方式三，可以使用@Param注解，给mapper接口方法的参数命名，在SQL中直接使用取的名字来引用</p>
<h3 id="78-嵌套子查询和JOIN有什么区别？"><a href="#78-嵌套子查询和JOIN有什么区别？" class="headerlink" title="78.嵌套子查询和JOIN有什么区别？"></a>78.嵌套子查询和JOIN有什么区别？</h3><p>嵌套子查询，指的是在查询一个主对象的时候，使用单表查询，在resultmap中额外发送一个子sql查询关联对象，然后映射给主对象</p>
<p>连表join查询，指的是查询一个主对象的时候，使用join连表的方式把主对象和关联对象的数据一次性查出来，用resultmap映射结果</p>
<p>他们的区别，join连表查询只发一条sql就能把数据查询出来，嵌套子查询会有一个n+1的问题，就是说如果主查询出来n条数据，那么会额外发送n条子sql去查询对应的关联对象，加上主查询那1次，也就是n+1次，因此它的性能相对较低的，一般我们会使用join连表查询</p>
<h3 id="79-在ResultMap中多对一关联对象查询用什么？一对多关联查询用什么？"><a href="#79-在ResultMap中多对一关联对象查询用什么？一对多关联查询用什么？" class="headerlink" title="79.在ResultMap中多对一关联对象查询用什么？一对多关联查询用什么？"></a>79.在ResultMap中多对一关联对象查询用什么？一对多关联查询用什么？</h3><p>单个关联对象用associate ，适用于多对一的关联查询，使用javaType来定义实体类型</p>
<p>集合用collection，适用于一对多的关联查询，使用ofType来定义集合的泛型类型</p>
<h3 id="80-Spring的Bean被指定为prototype以及singleton有什么区别"><a href="#80-Spring的Bean被指定为prototype以及singleton有什么区别" class="headerlink" title="80.Spring的Bean被指定为prototype以及singleton有什么区别"></a>80.Spring的Bean被指定为prototype以及singleton有什么区别</h3><p>这两者分别指的是多例和单例模式，singleton即单例模式，指对象在整个系统中只存在一份；prototype即多例模式系统中可以有多个实例。</p>
<p>如果一个bean是单例模式的，在处理多次请求的时候，在ioc容器中只实例化一个bean，这个对象会被保存在一个map中，当有请求来的时候，会先从map中查看，如果有就直接使用这个对象，没有才会实例化新的对象。</p>
<p>如果是多例模式的bean，每次请求来的时候，会直接实例化新的bean，没有map缓存的过程。</p>
<p>在spring的ioc容器中的bean默认都是单例的，如果需要使用多例，可以指定scope属性：scope=”prototype”</p>
<h3 id="81-说一下Sping的Bean的生命周期"><a href="#81-说一下Sping的Bean的生命周期" class="headerlink" title="81.说一下Sping的Bean的生命周期"></a>81.说一下Sping的Bean的生命周期</h3><p>Bean的生命周期包括实例化、属性赋值、初始化、销毁四个阶段</p>
<p>实例化，指的是通过构造函数创建bean</p>
<p>属性赋值，指的是为bean设置相关书信和依赖</p>
<p>初始化，是指spring容器调用指定的初始化方法，如果我们指定了bean的init-method方法，此时会调用执行</p>
<p>销毁，是指spring容器调用指定的销毁方法，如果我们指定了bean的destroy-method方法，此时会调用执行</p>
<h3 id="82-RequestMapping-和-GetMapping有什么区别？"><a href="#82-RequestMapping-和-GetMapping有什么区别？" class="headerlink" title="82.RequestMapping 和 GetMapping有什么区别？"></a>82.RequestMapping 和 GetMapping有什么区别？</h3><p>@Getmapping是一个组合注解，即是@RequestMapping(method =  RequestMethod.GET)的缩写，意思是只接收get请求的方法</p>
<p>@Requestmapping如果没有指定请求方式，可以接收get，put等各种类型的请求</p>
<h3 id="83-SpringMVC怎么样设定重定向和转发的"><a href="#83-SpringMVC怎么样设定重定向和转发的" class="headerlink" title="83.SpringMVC怎么样设定重定向和转发的"></a>83.SpringMVC怎么样设定重定向和转发的</h3><p>重定向是指将用户从当前请求重新定向到一个视图页面，或者是一个handler处理请求，以前的request域中信息全部失效，同时地址栏会        发生变化，它是客户端行为</p>
<p>转发是指将用户从当前请求转发给另一个视图页面或者handler处理请求，以前的request域可以共享，地址栏不会发生变化，它是服务器        行为</p>
<p>springmvc默认是使用转发方式跳转的，且会默认经过视图解析器</p>
<p>我们也可以通过指定，转发时在返回值前面加”forward:”，重定向时在返回值前面加”redirect:”，且此时就不会再经过视图解析器了</p>
<h3 id="84-SpringMVC如何对时间格式的参数进行格式化？有哪些方式？"><a href="#84-SpringMVC如何对时间格式的参数进行格式化？有哪些方式？" class="headerlink" title="84.SpringMVC如何对时间格式的参数进行格式化？有哪些方式？"></a>84.SpringMVC如何对时间格式的参数进行格式化？有哪些方式？</h3><p>​    第一种需求，后台接收前台页面返回的string类型时间，要转换成的Date类型数据，可以使用@DateTimeFormat注解来接收参数</p>
<p>​    第二种需求，后台将Date类型数据返回给前台页面，默认是返回时间戳，如果想要优雅的格式，可以在模型的Date字段或get方法上使用@JsonFormat注解</p>
<h3 id="85-SpringMVC常用的注解有哪些"><a href="#85-SpringMVC常用的注解有哪些" class="headerlink" title="85.SpringMVC常用的注解有哪些"></a>85.SpringMVC常用的注解有哪些</h3><p>@Controller：用来标识一个类是控制器类</p>
<p>@RequestMapping：用来映射请求路径和参数</p>
<p>@ResponseBody：将返回值放到responsebody中，通常返回json或者xml格式数据</p>
<p>@RequestBody：将前台请求参数转换成对象</p>
<p>@PathVariable：接收路径参数，通常用在restful接口中</p>
<p>@RestController：@Controller和@ResponseBody的组合注解</p>
<p>@ControllerAdvice：运用aop的思想，对全局做一些处理，比如结合@ExceptionHandler做全局异常捕获</p>
<h3 id="86-如何定义SpringMVC的拦截器"><a href="#86-如何定义SpringMVC的拦截器" class="headerlink" title="86.如何定义SpringMVC的拦截器"></a>86.如何定义SpringMVC的拦截器</h3><p>SpringMVC 的拦截器主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、判断登录等功能上</p>
<p>​        第1步，定义拦截器：可以实现 HandlerInterceptor 接口来自定义拦截器，接口定义了三个方法，preHandler方法是在请求到达处理器之前执行，postHandler方法是在请求经过处理器之后、解析试图之前执行，afterCompletion方法是在视图渲染之后、返回客户端之前执行</p>
<p>​        第2步，配置拦截器：在springmvc的配置文件xml中，配置所有拦截路径，以及需要放行的路径</p>
<h3 id="87-HandlerInterceptor和HandlerInterceptorAdapter的区别"><a href="#87-HandlerInterceptor和HandlerInterceptorAdapter的区别" class="headerlink" title="87.HandlerInterceptor和HandlerInterceptorAdapter的区别"></a>87.HandlerInterceptor和HandlerInterceptorAdapter的区别</h3><p>HandlerInterceptor是接口，我们可以实现该接口来定义拦截器，</p>
<p>HandlerInterceptorAdapter是抽象类，它实现了HandlerInterceptor接口的子接口AsyncHandlerInterceptor，我们可以继承该类来定义拦截器，它简化拦截器的实现，默认preHandler返回true</p>
<h3 id="88-pringMVC的执行原理"><a href="#88-pringMVC的执行原理" class="headerlink" title="88.pringMVC的执行原理"></a>88.pringMVC的执行原理</h3><p>​    1.Http请求：客户端请求提交到DispatcherServlet-前端控制器</p>
<p>​    2.寻找处理器：由DispatcherServlet调用HandlerMapping-处理器映射器，根据url找到对应的的Handler</p>
<p>​    3.调用处理器：DispatcherServlet指定HandlerAdapter-处理器适配器去调用Handler</p>
<p>​    4.调用业务处理和返回结果：Handler调用业务逻辑处理完成后，返回ModelAndView</p>
<p>​    5.处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler-视图解析器，找到ModelAndView指定的视图</p>
<p>​    6.Http响应：将结果显示到客户端</p>
<h3 id="89-SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决？"><a href="#89-SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决？" class="headerlink" title="89.SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决？"></a>89.SpringMVC的Controller是单例还是多例，有没有并发安全问题，如何解决？</h3><p>在spring中，bean默认都是单例的，controller也是交给spring容器管理的一个bean，因此它也是单例的。</p>
<p>单例的好处是减少了创建对象和垃圾回收的时间，节省了内存资源，但同时单例会造成线程不安全的问题，因为当所有请求访问同一个controller实例，controller中的成员变量是所有线程公用的，某个线程如果修改了这个变量，别的请求再来拿这个变量就编程修改后的值了</p>
<p>要解决这个问题，最直接有效的方式就是不要在controller中定义成员变量，如果你非要定义成员变量，两种方式</p>
<p>第一种，可以给controller上加注解@Scope(“prototype”)，将controller设置为多例模式，每次请求都重新实例化一个controller</p>
<p>第二种，使用ThreadLocal变量，让每一个线程都有自己独立的变量</p>
<h3 id="90-Spring-Boot有哪些优点"><a href="#90-Spring-Boot有哪些优点" class="headerlink" title="90.Spring Boot有哪些优点"></a>90.Spring Boot有哪些优点</h3><p>Springboot是一个基于spring的框架，对spring做了大量简化，使开发流程更快，更高效</p>
<p>它大量简化maven依赖，管理了大量的基础依赖</p>
<p>基于注解配置（JavaConfig），无需xml配置</p>
<p>内嵌Tomcat，部署流程简单</p>
<p>打包和部署更加灵活，允许独立运行</p>
<h3 id="91-SpringBoot如何做全局异常处理"><a href="#91-SpringBoot如何做全局异常处理" class="headerlink" title="91.SpringBoot如何做全局异常处理?"></a>91.SpringBoot如何做全局异常处理?</h3><p>可以使用@ControllerAdvice注解，编写一个全局异常处理类，再自定义一个方法使用@ExceptionHandler来捕获具体的异常并作相应的处理</p>
<p>通常情况下后台向前台返回结果时，会把结果封装成包含有错误码，错误信息以及数据本身的json数据，因此我们可以使用自定义异常类，自定义枚举错误码，在捕获全局异常后，向前台返回一个包含错误码的信息</p>
<h3 id="92-RabbitMQ的使用场景"><a href="#92-RabbitMQ的使用场景" class="headerlink" title="92.RabbitMQ的使用场景"></a>92.RabbitMQ的使用场景</h3><p>rabbitMQ消息队列可以用来</p>
<p>​    做任务的异步处理，提高程序的相应时间</p>
<p>​    提高系统稳定性，通过手动确认机制，当消费者出现故障，只要没有确认签收，请求的数据都不会丢失可以再次处理</p>
<p>​    服务解耦，生产者通过MQ与消费者交互</p>
<p>​    消除峰值，通过异步处理，消息传到MQ直接返回，接着等待排队处理，避免了线路拥堵</p>
<h3 id="93-RabbitMQ如何防止消息丢失"><a href="#93-RabbitMQ如何防止消息丢失" class="headerlink" title="93.RabbitMQ如何防止消息丢失"></a>93.RabbitMQ如何防止消息丢失</h3><p>​    首先，RabbitMQ的消息确认机制，默认是自动签收，也就是说消息一旦被消费者接收，就自动签收，消息就从队列里清除了。因此对于重要的消息，不容丢失的数据，我们需要设置在消费完成后手动签收</p>
<p>​    其次，我们可以将消息持久化，避免消息在消费前MQ宕机，网络问题等造成的消息丢失</p>
<h3 id="94-RabbitMQ的交换机有哪几种"><a href="#94-RabbitMQ的交换机有哪几种" class="headerlink" title="94.RabbitMQ的交换机有哪几种"></a>94.RabbitMQ的交换机有哪几种</h3><p>​    Fanout：广播，将消息交给所有绑定到交换机的队列</p>
<p>​    Direct：定向，把消息交给符合指定routing key的队列</p>
<p>​    Topic：通配符，把消息交给符合routing pattern的队列</p>
<h3 id="95-消息是如何从发送者到达消费者的（RabbitMQ工作流程）"><a href="#95-消息是如何从发送者到达消费者的（RabbitMQ工作流程）" class="headerlink" title="95.消息是如何从发送者到达消费者的（RabbitMQ工作流程）"></a>95.消息是如何从发送者到达消费者的（RabbitMQ工作流程）</h3><p>分为消息发送和消息接收两个步骤</p>
<p>​    消息发送：生产者和Broker建立TCP连接，创建信道。通过信道将消息发送给Broker，由Exchange将消息进行转发到指定的队列</p>
<p>​    消息接收：消费者和Broker建立TCP连接 ，创建信道 ，然后监听指定的队列，当有消息到达队列时，Broker默认将消息推送给消费者，消费者就能接收到消息</p>
<h3 id="96-如何防止消息重复消费？"><a href="#96-如何防止消息重复消费？" class="headerlink" title="96.如何防止消息重复消费？"></a>96.如何防止消息重复消费？</h3><p>重复消费，一般时由于消费者消费成功后，在给MQ确认签收的时候出现了网络波动，MQ没有接到确认，就会继续给消费者投递之前的消息，造成消费者接收到了两条一样的消息。</p>
<p>我们可以通过实现消息的幂等性来避免这种情况，比如说让生产者给每个消息携带一个唯一的id，消费者获取消息后根据这个id去查询数据库，如果不存在就正常消费，如果存在了就证明该消息被消费过，直接丢弃</p>
<h3 id="97-Lucene创建索引原理"><a href="#97-Lucene创建索引原理" class="headerlink" title="97.Lucene创建索引原理"></a>97.Lucene创建索引原理</h3><p>Lucene是基于倒排索引原理来实现的</p>
<p>​    首先，将原文档进行分词处理，形成一个个单独的单词，</p>
<p>​    然后取出标点符号以及停词，形成词元，</p>
<p>​    再将词元做一些语言相关的处理，比如变成小写，转换时态，单复数形式等等，</p>
<p>​    将得到的词创建一个字典，按照字母顺序排序，合并相同的词，最终生成一个倒排索引文档</p>
<h3 id="98-ES的优势"><a href="#98-ES的优势" class="headerlink" title="98.ES的优势"></a>98.ES的优势</h3><p>ES是基于Lucene的开源搜索引擎，它解决了原生Lucene使用的不足，优化了Lucene的调用方式</p>
<p>​    分布式的实时文件存储，每个字段都被索引并可被搜索<br>​    支持实时分析搜索<br>​    可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>​    通过简单的 RESTful API、可以跟各种语言的客户端甚至命令行进行交互<br>​    上手非常容易，只需很少的学习就可以在生产环境中使用</p>
<h3 id="99-Lucene-ES为什么那么快-ES用到什么数据结构"><a href="#99-Lucene-ES为什么那么快-ES用到什么数据结构" class="headerlink" title="99.Lucene/ES为什么那么快(ES用到什么数据结构)"></a>99.Lucene/ES为什么那么快(ES用到什么数据结构)</h3><p>传统搜索比如mysql的like关键字查询，它的搜索方式就是全文扫表，查询性能很低</p>
<p>ES是基于Lucene的全文检索引擎，它采用的是倒排索引结构，在存储时先对文档进行分词，再做一些标点符号去除，大小写时态转换等优化处理，最后按照字母顺序去重排序，形成一个倒排索引文档，我们在检索时，就可以通过二分查找的方式找到目标值</p>
<h3 id="100-ES的分层结构，index下面是什么？"><a href="#100-ES的分层结构，index下面是什么？" class="headerlink" title="100.ES的分层结构，index下面是什么？"></a>100.ES的分层结构，index下面是什么？</h3><p>Index：索引库，包含有一堆相似结构的文档数据，类比Mysql中的数据库</p>
<p>Type：类型，它是index中的一个逻辑数据分类，类比Mysql中的表</p>
<p>Document：文档：是ES中的最小数据单元，通常用json结构标识，类比Mysql中的一行数据</p>
<p>Field：字段：类比Mysql中的一个列</p>
<p>从ES7.0开始，Type被干掉了，从此库表合一即一个Index中只有一个默认的Type</p>
<h3 id="101-讲几个ES中的查询对象：比如TermQuery"><a href="#101-讲几个ES中的查询对象：比如TermQuery" class="headerlink" title="101.讲几个ES中的查询对象：比如TermQuery"></a>101.讲几个ES中的查询对象：比如TermQuery</h3><p>TermQuery：匹配关键字查询（关键词不分词）</p>
<p>MatchQuery：匹配关键字查询（关键字分词后）</p>
<p>BooleanQuery：按条件查询</p>
<p>matchAllQuery：匹配所有文档查询</p>
<p>rangeQuery：查询指定范围内的数据</p>
<h3 id="102-你怎么判断一个字段要不要创建索引"><a href="#102-你怎么判断一个字段要不要创建索引" class="headerlink" title="102.你怎么判断一个字段要不要创建索引"></a>102.你怎么判断一个字段要不要创建索引</h3><p>需要经常关键字查询的字段需要创建索引</p>
<h3 id="103-你简单描述一下DSL语法"><a href="#103-你简单描述一下DSL语法" class="headerlink" title="103.你简单描述一下DSL语法"></a>103.你简单描述一下DSL语法</h3><p>DSL是一种以json形式标识的，由ES提供的一种查询语言，它由两部分组成，DSL查询和DSL过滤。</p>
<p>DSL过滤类似于模糊查询，DSL查询类似于精确查询</p>
<h3 id="104-你说一下-match和term的区别？"><a href="#104-你说一下-match和term的区别？" class="headerlink" title="104.你说一下 match和term的区别？"></a>104.你说一下 match和term的区别？</h3><p>term：不会对搜索词进行分词处理，而是作为一个整体与目标字段进行匹配，若完全匹配，则可查询到</p>
<p>match：会将搜索词分词，再与目标查询字段进行匹配，若分词中的任意一个词与目标字段匹配上，则可查询到</p>
<h3 id="105-项目并发高处理过不过来怎么办"><a href="#105-项目并发高处理过不过来怎么办" class="headerlink" title="105.项目并发高处理过不过来怎么办"></a>105.项目并发高处理过不过来怎么办</h3><p>前端优化：</p>
<p>​    使用页面静态化技术由Nginx实现动静分离、CDN加速加快响应速度、使用验证码使流量错峰等手段最大限度的降低并发</p>
<p>后端优化：</p>
<p>​    从架构上使用分布式、集群分散并发量，</p>
<p>​    从数据结构上使用缓存如Redis减少数据读写时间，</p>
<p>​    从处理方式上采用如RabitMQ队列实现异步响应，</p>
<p>​    资源隔离比如使用Hystrix的信号量隔离来限流，同时做好备用方案比如Hystrix的熔断降级策略等等</p>
<h3 id="106-什么是集群"><a href="#106-什么是集群" class="headerlink" title="106.什么是集群"></a>106.什么是集群</h3><p>集群使将应用复制成多个相同的应用，一起来工作，从而提高工作能力。即将多个应用程序分散在不同的服务器，每个服务器都独立运行相同的代码。可以分散服务器压力解决高并发的问题，同时也能预防单节点故障，即一台服务器故障不影响其他服务器正常运行，但没有解决单体应用代码臃肿，业务复杂，维护性差等等问题</p>
<h3 id="107-什么是负载均衡"><a href="#107-什么是负载均衡" class="headerlink" title="107.什么是负载均衡"></a>107.什么是负载均衡</h3><p>使用了集群后，解决高并发同时有一个新的问题，就是客户端的请求如何分配到多台服务。因此需要通过负载均衡器，比如Nginx，使用负载均衡算法比如轮询、权重、随机等等将请求路由到不同的服务器</p>
<h3 id="108-什么是分布式"><a href="#108-什么是分布式" class="headerlink" title="108.什么是分布式"></a>108.什么是分布式</h3><p>分布式是将应用按照业务类型拆分成多个子应用，每个子应用部署在不同的服务器上单独运行，子应用之间通过API相互调用。</p>
<p>可以分散服务器压力解决高并发问题，同时可以解决单体应用代码臃肿、业务复杂、维护性差等等问题，但是不能防止单节点故障，比如一个子应用故障，整个应用就能不完整运行</p>
<h3 id="109-集群和分布式的区别，分别解决什么问题"><a href="#109-集群和分布式的区别，分别解决什么问题" class="headerlink" title="109.集群和分布式的区别，分别解决什么问题"></a>109.集群和分布式的区别，分别解决什么问题</h3><p>集群是将一个应用程序复制多份，部署在多台服务器上，每个服务器中的程序都是完整的，可以独立运行</p>
<p>分布式是将一个应用程序拆分成多个子程序，分别部署在多台服务器上，每个服务器中的程序都是不完整的，所有服务器需要相互通信相互协调才能完成最终的业务</p>
<p>集群能解决高并发问题，同时能防止单节点故障，即一台服务器宕机不影响其他服务器的正常运行</p>
<p>分布式也能解决高并发问题，但不能防止单节点故障，即一台服务器宕机了，整体业务就无法完成</p>
<p>集群无法解决项目本身的代码臃肿、业务复杂等等问题，分布式能降低模块之间的耦合</p>
<p>实际应用中，我们可以将分布式和集群相结合，比如分布式某个子程序的负载很高，可以单独对这个子程序做集群</p>
<h3 id="110-说一下你理解的微服务"><a href="#110-说一下你理解的微服务" class="headerlink" title="110.说一下你理解的微服务"></a>110.说一下你理解的微服务</h3><p>微服务也是一个分布式系统，它将单体应用进行细粒度拆分，形成多个微服务，每个服务独立运行，每个服务也都可以有自己的数据库，服务之间使用HTTP通信，互相协调完成整个系统的业务。</p>
<p>它的优点是服务之间解耦合，不同的服务可以有不同的编程语言，技术选型多元化，支持敏捷开发</p>
<p>他的缺点是分布式事务很复杂，部署麻烦，技术成本高，服务间通信对性能也有一定的损耗</p>
<h3 id="111-讲一下你们公司微服务解决方案"><a href="#111-讲一下你们公司微服务解决方案" class="headerlink" title="111.讲一下你们公司微服务解决方案"></a>111.讲一下你们公司微服务解决方案</h3><p>我司正在使用的是第一代微服务方案，Springcloud Netflix全家桶。</p>
<p>它是使用Eureka做服务注册与发现，也就是解决服务之间通信问题，</p>
<p>使用Ribbon/OpenFeign做客户端的负载均衡，也就是解决将请求路由到微服务集群的问题，</p>
<p>使用Hystrix断路器的熔断、降级来解决单节点故障，</p>
<p>使用Zuul做服务网关，将它作为整个微服务的大门，来实现登录、权限检查等业务，</p>
<p>使用Config分布式配置中心，来统一管理配置所有微服务的配置文件，</p>
<p>使用Bus消息总线给各个微服务广播消息，可以实现各个微服务配置的自动刷新，</p>
<p>使用Sleuth链路追踪，来实时监控各个微服务建的调用关系，快速定位故障节点</p>
<h3 id="112-说一说Spring-Cloud有哪些常用组件，分别有什么用？"><a href="#112-说一说Spring-Cloud有哪些常用组件，分别有什么用？" class="headerlink" title="112.说一说Spring Cloud有哪些常用组件，分别有什么用？"></a>112.说一说Spring Cloud有哪些常用组件，分别有什么用？</h3><p>Eureka：做服务注册与发现，用来解决服务之间通信问题，</p>
<p>Ribbon/OpenFeign：用做客户端的负载均衡，也就是解决将请求路由到微服务集群的问题，</p>
<p>Hystrix：断路器，它的熔断、降级策略用来解决单节点故障，</p>
<p>Zuul：做服务网关，它是整个微服务的大门，可以用来实现登录、权限检查等业务，</p>
<p>Config：分布式配置中心，用来统一管理配置所有微服务的配置文件，</p>
<p>Bus：消息总线，用来给各个微服务广播消息，可以实现各个微服务配置的自动刷新，</p>
<p>Sleuth：链路追踪，用来实时监控各个微服务建的调用关系，快速定位故障节点</p>
<h3 id="113-Spring-Cloud的优缺点？"><a href="#113-Spring-Cloud的优缺点？" class="headerlink" title="113.Spring Cloud的优缺点？"></a>113.Spring Cloud的优缺点？</h3><p>微服务相对单体应用来说</p>
<p>优点</p>
<p>​        服务之间无耦合，代码简单方便开发维护，服务之间升级维护互不影响<br>​        轻量级HTTP通信机制，不同的服务可以采用不同的编程语言<br>​        有极强的扩展能力,业务量大的服务可以再次拆分服务，或者也可以集群部署<br>​        支持时下流行的敏捷开发并做了优化</p>
<p>缺点</p>
<p>​        分布式事务繁琐</p>
<p>​        部署麻烦，开发人员的学习成本高</p>
<p>​        技术成本高，开发人员需要花更多的时间学习相关技术</p>
<p>​        微服务间的通信存在对性能的损耗问题</p>
<h3 id="114-什么是服务注册"><a href="#114-什么是服务注册" class="headerlink" title="114.什么是服务注册"></a>114.什么是服务注册</h3><p>Eureka是一个服务组测与发现的组件，翻译成人话就是管理所有微服务的通讯录的组件。它包含注册中心，客户端两部分组成。客户端在启动的时候会向注册中心发送一条自我介绍信息，比如端口，ip等等，在注册中心就会保存一张所有微服务的通讯录。这就叫服务注册</p>
<h3 id="115-什么是服务发现"><a href="#115-什么是服务发现" class="headerlink" title="115.什么是服务发现"></a>115.什么是服务发现</h3><p>微服务会定期的从客户端拉取一份微服务通讯录，到本地缓存起来，默认是30s一次。当一个微服务向另一个微服务发起调用，直接根据本地的通讯录找到对方的服务名，发送HTTP请求。这个就叫服务发现</p>
<h3 id="116-什么是服务续约"><a href="#116-什么是服务续约" class="headerlink" title="116.什么是服务续约"></a>116.什么是服务续约</h3><p>微服务会定时（默认30s）发送心跳请求，告诉注册中心，自己还处于存活状态，那么服务中心就不会将其从清单中删除，否则，当微服务宕机或者网络故障等因素，没有在规定时间（默认90s）内提交心跳请求，注册中心就会将它从通讯录中删除。</p>
<h3 id="117-如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？"><a href="#117-如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？" class="headerlink" title="117.如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？"></a>117.如果服务挂了，注册中心要等到90s后剔除，那么在剔除前的这段时间内，挂掉的服务有可能还是会被调用，怎么处理？</h3><p>第一，可以修改注册中心剔除服务时间，同时加快服务续约心跳请求的频率</p>
<p>第二，可以使用Hystrix的熔断降级机制，当某个服务不可访问，快速失败，并返回托底数据</p>
<p>第三。重试</p>
<h3 id="118-你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？"><a href="#118-你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？" class="headerlink" title="118.你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？"></a>118.你知道EurekaClient服务发现和服务续约每隔30s做一次请求是用什么技术实现的吗？</h3><p>使用了ScheduledThreadPoolExecutor线程池定时任务来实现</p>
<p>服务发现是先判断是否开启了服务发现功能（默认是开启的），获取定时任务的间隔时间（默认是30s），然后初始化服务发现的定时任务，间隔时间可以在yml中修改</p>
<p>服务续约是先判断是否开启服务注册功能（默认是开启的），获取定时任务间隔时间（默认是30s），然后初始化心跳请求的定时任务，间隔时间可以在yml中修改</p>
<h3 id="119-Ribbon是什么，Ribbon的工作原理讲一下"><a href="#119-Ribbon是什么，Ribbon的工作原理讲一下" class="headerlink" title="119.Ribbon是什么，Ribbon的工作原理讲一下"></a>119.Ribbon是什么，Ribbon的工作原理讲一下</h3><p>Ribbon是一个负债均衡器，它可以按照负债均衡算法，向多个服务发起调用。当一个微服务有多个集群时，就可以使用它做请求的分发</p>
<p>当我们需要调用一组集群服务时，ribbon会根据服务名，在本地缓存的通讯地址里找到这一组服务的通讯地址，然后按照负债均衡算法（默认是轮询），选择其中的一个通讯地址，发起http调用服务</p>
<h3 id="120-Ribbon有哪些负载均衡算法，怎么配置"><a href="#120-Ribbon有哪些负载均衡算法，怎么配置" class="headerlink" title="120.Ribbon有哪些负载均衡算法，怎么配置"></a>120.Ribbon有哪些负载均衡算法，怎么配置</h3><p>RoundRobinRule：简单轮询，ribbon默认规则</p>
<p>AvailabilityFilteringRule：忽略短路状态和并发过高的服务器</p>
<p>WeightedResponseTimeRule：根据服务器响应时间作为权重，响应时间越长权重越小</p>
<p>ZoneAvoidanceRule：根据区域选择</p>
<p>BestAvailableRule：忽略短路的服务器，选择并发较低的服务器</p>
<p>RandomRule：随机选择一个可用服务器</p>
<p>Retry：重试机制的选择逻辑</p>
<h3 id="121-OpengFiegn的工作流程"><a href="#121-OpengFiegn的工作流程" class="headerlink" title="121.OpengFiegn的工作流程"></a>121.OpengFiegn的工作流程</h3><p>首先，当程序启动时，使用了@FeignClient注解的接口会被扫描并交给Spring容器管理。</p>
<p>当发起请求时，会使用jdk动态代理，并为每个方法都生成相应的RequestTemplate，同时封装http信息，包括url和请求参数等，</p>
<p>最后，由RestTemplate生成request请求，使用ribbon的负载均衡发起调用</p>
<h3 id="122-为什么Feign的客户端接口没有写实现类也可以直接被依赖注入"><a href="#122-为什么Feign的客户端接口没有写实现类也可以直接被依赖注入" class="headerlink" title="122.为什么Feign的客户端接口没有写实现类也可以直接被依赖注入"></a>122.为什么Feign的客户端接口没有写实现类也可以直接被依赖注入</h3><p>​    自动注入的实例其实是一个jdk动态代理对象，Feign会为每个方法生成相应的requestTemplate，它根据服务名找到对应的服务，根据返回值类型、形参列表匹配相应的接口，然后封装url、请求参数，最后生成request请求，使用Ribbon负载均衡发起调用</p>
<h3 id="123-介绍一下Hystrix"><a href="#123-介绍一下Hystrix" class="headerlink" title="123.介绍一下Hystrix"></a>123.介绍一下Hystrix</h3><p>Hystrix意为熔断器，它可以将出现故障的服务，通过熔断、降级等手段隔离开，这样不影响整个系统的主业务。它可以防止由单节点异常导致整个微服务故障，如果遇到故障时，快速失败，熔断的同时可以返回兜底数据达到服务降级的目的</p>
<h3 id="124-什么是熔断，什么是降级"><a href="#124-什么是熔断，什么是降级" class="headerlink" title="124.什么是熔断，什么是降级"></a>124.什么是熔断，什么是降级</h3><p>熔断，是对服务链路的一种保护机制，当链路上的某个服务不可访问时，服务就会触发降级返回拖地数据，同时当失败率到达一个阈值，就标记该服务为短路状态，当请求访问时直接熔断。直到检查到该服务能正常访问时，就快速恢复</p>
<p>降级，是当某个服务不可访问时，我们返回一些事先准备好的数据给客户端，比如说，友情提示服务暂不可用，请骚后重试，这样用户体验就上去了</p>
<h3 id="125-什么是资源隔离？"><a href="#125-什么是资源隔离？" class="headerlink" title="125.什么是资源隔离？"></a>125.什么是资源隔离？</h3><p>指的是限制某一个分布式服务的资源使用，可以理解为限流，也就是限制某个服务的请求数量。它包括线程池隔离和信号量隔离</p>
<p>线程池隔离，是指用一个线程池来存储当前请求，可以通过设置线程池最大线程数和最大排队队列数来限制请求数量</p>
<p>信号量隔离：是指用一个计数器来记录当前有多少个线程在运行，请求进来计数器就增加1，超过最大信号量，就直接返回</p>
<h3 id="126-资源隔离：信号量和线程池的区别"><a href="#126-资源隔离：信号量和线程池的区别" class="headerlink" title="126.资源隔离：信号量和线程池的区别"></a>126.资源隔离：信号量和线程池的区别</h3><p>线程池方式是异步处理，它与调用线程不是同一个线程</p>
<p>信号量方式是同步处理，与调用线程是同一个线程</p>
<p>线程池方式由于需要排队，调度，线程切换，因此开销较大，信号量方式无需切换线程，开销较小</p>
<h3 id="127-对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？"><a href="#127-对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？" class="headerlink" title="127.对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？"></a>127.对于CAP理论，Eureka选择的是AP还是CP？它保证了一致性还是可用性？</h3><p>CAP理论指的是，一个分布式系统中，一致性，可用性，分区容错性，三个要素只能同时实现两点。Eureka选择的是AP，它是弱一致性的，保证了可用性和分区容错性，放弃了数据一致性。也就是说当多个Eureka之间不可通信时，需要保证服务可用，正常提供服务注册发现功能，但是网络恢复后最终还是会同步的。</p>
<h3 id="128-说一下Eureka的自我保护"><a href="#128-说一下Eureka的自我保护" class="headerlink" title="128.说一下Eureka的自我保护"></a>128.说一下Eureka的自我保护</h3><p>为了防止服务被误删除，Eureka不会立即删除过时的服务数据。这种机制可能会导致客户端从注册中心获取到已经下线的服务并发起调用而导致错误，因此在开发阶段我们可以关闭自我保护机制。在生产环境中，我们需要打开自我保护，因为它可以防止因为网络波动，服务没有及时续约而造成的服务误删除问题。</p>
<h3 id="129-你们项目是如何做服务降级的？"><a href="#129-你们项目是如何做服务降级的？" class="headerlink" title="129.你们项目是如何做服务降级的？"></a>129.你们项目是如何做服务降级的？</h3><p>比如在秒杀业务中，需要实时从redis中查询库存，通过设置hystrix的最大信号量，以此来防止redis雪崩。当并发过高，请求数超过最大信号量，触发降级，直接向客户端返回兜底数据：”活动太火爆啦，请骚后重试“</p>
<h3 id="130-Zuul有哪几类Filter-他们的执行顺序是怎么样的？"><a href="#130-Zuul有哪几类Filter-他们的执行顺序是怎么样的？" class="headerlink" title="130.Zuul有哪几类Filter,他们的执行顺序是怎么样的？"></a>130.Zuul有哪几类Filter,他们的执行顺序是怎么样的？</h3><p>zuul按照执行顺序，分为pre前置过滤，route路由过滤，post后置过滤，error异常后过滤</p>
<p>正常流程是请求先经过前置过滤器，到达路由过滤器进行路由，路由到各种微服务执行请求，返回结果后经过后置过滤，返回用户</p>
<p>异常流程，如果再整个过程中出现异常，都会进入error异常过滤器，处理完毕后经过post过滤器返回用户，如果error自己出现异常，最终也会通过post过滤器返回用户，如果post过滤器出现异常，也会跳转到error过滤器，然后直接返回用户</p>
<h3 id="131-在Zuul中做登录检查如何实现？"><a href="#131-在Zuul中做登录检查如何实现？" class="headerlink" title="131.在Zuul中做登录检查如何实现？"></a>131.在Zuul中做登录检查如何实现？</h3><p>可以通过继承ZuulFilter抽象类，自定义pre类型的过滤器，shouldFilter方法中可以定义需要放行的资源，run方法中检查请求头中的token信息，如果没有token，就响应到客户端未登录的信息，并组织filter继续往后执行</p>
<h3 id="132-在Zuul中如何做限流？"><a href="#132-在Zuul中如何做限流？" class="headerlink" title="132.在Zuul中如何做限流？"></a>132.在Zuul中如何做限流？</h3><p>方式一：可以通过继承ZuulFilter抽象类自定义pre过滤器，加上限流算法，来实现</p>
<p>方式二：可以通过hystrix的资源隔离模式，设置线程池最大连接数或者最大信号量来实现</p>
<p>方式三：常用，Ratelimit，使用令牌桶算法。。。</p>
<h3 id="133-了解SpringCloud源码吗？"><a href="#133-了解SpringCloud源码吗？" class="headerlink" title="133.了解SpringCloud源码吗？"></a>133.了解SpringCloud源码吗？</h3><p>。。。</p>
<h3 id="134-配置中心解决什么问题？"><a href="#134-配置中心解决什么问题？" class="headerlink" title="134.配置中心解决什么问题？"></a>134.配置中心解决什么问题？</h3><p>在分布式系统中，服务数量很多，而每个服务都有自己的配置文件，管理起来很麻烦。配置中心是个好东西，可以帮我们集中管理配置文件，它支持本地配置文件，也支持将配置文件放到远程仓库如git集中管理。</p>
<h3 id="135-EureakServer的搭建流程"><a href="#135-EureakServer的搭建流程" class="headerlink" title="135.EureakServer的搭建流程"></a>135.EureakServer的搭建流程</h3><p>第一步，导入eureka-server依赖，以及springboot的web环境依赖。</p>
<p>第二布，主启动类上打注解，@EnableEurekaServer，开启eureka服务端功能</p>
<p>第三步，yml配置文件中，配置注册中心的端口号，主机名，注册中心地址</p>
<h3 id="136-Ribbon的整合流程"><a href="#136-Ribbon的整合流程" class="headerlink" title="136.Ribbon的整合流程"></a>136.Ribbon的整合流程</h3><p>第一步，导入ribbon依赖</p>
<p>第二部，给RestTemplate的Bean定义方法上，加上注解@LoadBalanced，让这个restTemplate有负载均衡的功能</p>
<p>第三步，修改restTemplate调用服务的url，将目标主机名换成目标服务名</p>
<h3 id="137-Feign的整合流程"><a href="#137-Feign的整合流程" class="headerlink" title="137.Feign的整合流程"></a>137.Feign的整合流程</h3><p>第一步，导入openfeign依赖</p>
<p>第二部，主配置类加注解，@EnableFeignClients，开启feign支持</p>
<p>第三步，定义feign客户端接口，并加上注释@FeignClient(“目标服务名”)，接口中定义方法，该方法与目标服务的对应方法的方法名，返回值类型，形参列表，url路径要一致</p>
<h3 id="138-Hystrix的整合流程"><a href="#138-Hystrix的整合流程" class="headerlink" title="138.Hystrix的整合流程"></a>138.Hystrix的整合流程</h3><p>ribbon整合：</p>
<p>​    第一步，导入hystrix依赖</p>
<p>​    第二部，主启动类加注解，@EnableCircuitBreaker，开启熔断功能</p>
<p>​    第三步，在需要开启熔断功能的方法上，加注解@HystrixCommand(fallbackMethod=”xxx”)，xxx是降级方法</p>
<p>​    第四步，定义降级方法，方法名需要和fallbackMethod的值一致，形参列表和返回值类型需要和目标方法一致</p>
<p>feign整合：</p>
<p>​    第一步，yml中配置，feign.hystrix.enable=true，开启hystrix功能</p>
<p>​    第二部，@FeignClient标签中，定义fallback或者fallbackFactory，指定降级类</p>
<p>​    第三步，</p>
<p>​        如果是fallback，就实现feign接口，并覆写接口中的方法作为降级方法</p>
<p>​        如果是fallbackFactory，就实现FallbackFactory接口，同时指定泛型为feign接口，覆写create方法，返回一个feign接口的匿名内部类，类中写降级方法</p>
<h3 id="139-Zuul的整合流程"><a href="#139-Zuul的整合流程" class="headerlink" title="139.Zuul的整合流程"></a>139.Zuul的整合流程</h3><p>第一步，导入zuul依赖</p>
<p>第二步，主启动类上加注解@EnableZuulProxy，开启zuul功能</p>
<p>第三步，yml中配置，统一访问前缀prefix，禁用通过服务名方式访问服务ignoredServices，配置路由routes指定某个服务使用某个路径来访问</p>
<h3 id="140-ConfigServer的整合流程"><a href="#140-ConfigServer的整合流程" class="headerlink" title="140.ConfigServer的整合流程"></a>140.ConfigServer的整合流程</h3><p>配置中心服务端配置：</p>
<p>​    第一步，导入config-server依赖</p>
<p>​    第二步，主启动类加注解，@EnableConfigServer，开启配置中心</p>
<p>​    第三步，配置文件中，配置远程仓库地址，仓库账号密码</p>
<p>客户端配置：</p>
<p>​    第一步，导入config-client依赖</p>
<p>​    第二步，创建bootstrap.yml配置文件，配置中心地址config.uri，要拉取的配置文件名name，环境名profile</p>
<h3 id="141-你们微服务项目的技术栈描述一下"><a href="#141-你们微服务项目的技术栈描述一下" class="headerlink" title="141.你们微服务项目的技术栈描述一下"></a>141.你们微服务项目的技术栈描述一下</h3><p>​    前端门户系统：HTML + JQuery + CSS</p>
<p>​    前端管理系统：VUE + ElementUI</p>
<p>​    后端系统：基于SpringCloud微服务框架（Eureka+OpenFeign+Hystrix+Zuul+Config）</p>
<p>+MyBatisPlus+SpringMVC+Redis+ElasticSearch+RabbitMQ+AlicloudOSS</p>
<h3 id="142-浏览器发起一个请求，在你的微服务项目中的怎么去执行的？"><a href="#142-浏览器发起一个请求，在你的微服务项目中的怎么去执行的？" class="headerlink" title="142.浏览器发起一个请求，在你的微服务项目中的怎么去执行的？"></a>142.浏览器发起一个请求，在你的微服务项目中的怎么去执行的？</h3><p>浏览器发起的所有请求首先通过Nginx，通过负载均衡算法，路由给zuul集群，然后通过zuul前置过滤，作登录校验后，它会从配置中心拉取的通讯地址中，根据url匹配到对应的服务，然后使用ribbon发起restful调用。微服务间也可以通过feign相互调用，最终执行完任务，返回浏览器</p>
<h3 id="143-为什么要使用Redis做缓存"><a href="#143-为什么要使用Redis做缓存" class="headerlink" title="143.为什么要使用Redis做缓存"></a>143.为什么要使用Redis做缓存</h3><p>一个字，快。</p>
<p>缓存它指的是将数据库的数据同步到内存中，客户端获取数据直接从内存中获取。由于内存读写速度大于磁盘，而使用缓存能减少磁盘读取，大大提高查询性能。</p>
<p>我们一般会将经常查询的，不会经常改变的热点数据，保存到缓存中，提高响应速度</p>
<h3 id="144-缓存的执行流程"><a href="#144-缓存的执行流程" class="headerlink" title="144.缓存的执行流程"></a>144.缓存的执行流程</h3><p>1.客户端发起查询请求</p>
<p>2.判断缓存中是否有数据</p>
<p>​    如果有，直接返回</p>
<p>​    如果没有，就从数据库查询，再把数据同步到缓存</p>
<p>3.返回数据给客户端</p>
<h3 id="145-SpringCache常用注解"><a href="#145-SpringCache常用注解" class="headerlink" title="145.SpringCache常用注解"></a>145.SpringCache常用注解</h3><p>​    @EnableCaching：打在主启动类上，开启缓存功能</p>
<p>​    @Cacheable：打在方法上，表示该方法会开启缓存，打在类上，表示类中所有的方法都开启缓存</p>
<p>​    @CacheEvict：搭载类或者方法上，会将缓存清除</p>
<p>​    @CachePut：更新缓存</p>
<p>​    @Caching：组合操作，要应用于方法的多个缓存操作</p>
<p>​    @CacheConfig：打在类上，共享的一些常见缓存设置</p>
<h3 id="146-你们怎么保证Redis和Mysql的一致性"><a href="#146-你们怎么保证Redis和Mysql的一致性" class="headerlink" title="146.你们怎么保证Redis和Mysql的一致性"></a>146.你们怎么保证Redis和Mysql的一致性</h3><p>第一，对redis的操作，采用直接删除，因为redis存储的数据包括了数据库中的多个表，更新的性能比删除的性能低</p>
<p>第二，操作顺序，我们的业务对一致性要求不是很高，因此采用了先操作mysql，后删除redis，redis中缓存的数据对key都设置了过期时间，就算有缓存有脏数据，最终也会一致。</p>
<h3 id="147-京东的首页的商品分类，让你设计表，你怎么设计"><a href="#147-京东的首页的商品分类，让你设计表，你怎么设计" class="headerlink" title="147.京东的首页的商品分类，让你设计表，你怎么设计"></a>147.京东的首页的商品分类，让你设计表，你怎么设计</h3><p>首先可以看出表的结构是自关联，三层的树状结构，分类表的字段可以有主键id，商品名，创建时间，修改时间，上架时间，下架时间，商品数量，排序，图标，父级id</p>
<h3 id="148-如何查询出树状结构的课程分类数据"><a href="#148-如何查询出树状结构的课程分类数据" class="headerlink" title="148.如何查询出树状结构的课程分类数据"></a>148.如何查询出树状结构的课程分类数据</h3><p>首先，在entity中加入子分类字段children</p>
<p>查询方式有四种</p>
<p>​    第一，使用嵌套for循环，循环体内查询每一层级的数据，并关联到children。当然这也可以使用递归函数来实现</p>
<p>​    第二，使用mybatis的嵌套查询，也就是主查询加额外子sql查询的方式</p>
<p>​    第三，使用mybatis的嵌套结果，也就是join连表查询的方式</p>
<p>​    第四，只使用一次查询，将所有数据查询出来，通过一种算法来实现：除了第一级，其他所有数据都关联到自己的父级分类，结果返回第一级数据就可以</p>
<p>​    第一，第二种方式，当层级多的时候查询性能极低，第三种方式一般只能查询两层结构，第四种方式性能最高，适用于数据量本身并不大但层级很多的场景</p>
<p>所有课程的数据本身体量小，层级多，因此采用了第四种方式。</p>
<h3 id="149-你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？"><a href="#149-你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？" class="headerlink" title="149.你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？"></a>149.你们系统使用Redis缓存了哪些东西？用Redis的什么结构去存储的？</h3><p>登录信息login，使用的是String结构存储</p>
<p>手机验证码code，使用的是String结构</p>
<p>课程分类course_type ，使用的是String结构</p>
<p>购物车保存，使用的是Hash结构</p>
<h3 id="150-课程发布流程讲一下"><a href="#150-课程发布流程讲一下" class="headerlink" title="150.课程发布流程讲一下"></a>150.课程发布流程讲一下</h3><p>发布课程两大步</p>
<p>第一步，将课程的状态改为上线并保存到数据库中，</p>
<p>第二步，将课程信息保存到ES中，方便门户网站展示</p>
<h3 id="151-你们课程相关的表是怎么设计的？主要的字段说一下"><a href="#151-你们课程相关的表是怎么设计的？主要的字段说一下" class="headerlink" title="151.你们课程相关的表是怎么设计的？主要的字段说一下"></a>151.你们课程相关的表是怎么设计的？主要的字段说一下</h3><p>我们按照字段的使用频次，垂直分表来设计，分为课程主表，课程详情表，课程类型表，课程市场详情表。</p>
<p>课程主表，包括主键id，课程名称，课程类型id，课程上下线状态，适用人群，课程等级，课程所属机构等，并且冗余了课程类型名，课程价格字段来提高前台的查询性能</p>
<p>课程详情表，包括课程简介，课程详情</p>
<p>课程市场详情表，包括课程价格，促销活动，活动过期时间</p>
<p>课程类型表，包括主键id，类型名，创建修改时间，课程数量，父级id</p>
<p>其中课程主表和课程详情表、课程主表和课程市场详情表，都是一对一的关系，他们采用相同的主键id来相互关联。课程主表和课程类型表是多对一的关系，在课程主表添加类型id来相互关联</p>
<h3 id="152-讲一下你们这个项目的主线业务"><a href="#152-讲一下你们这个项目的主线业务" class="headerlink" title="152.讲一下你们这个项目的主线业务"></a>152.讲一下你们这个项目的主线业务</h3><p>我们项目分为两大版图，</p>
<p>入驻我们平台的培训机构，可以发布相关课程，入驻平台的企业，可以发布相关的就业招聘信息</p>
<p>门户网站的大众用户，可以选择培训机构发布的课程来进行学习，可以选择企业发布的招聘信息来就业</p>
<h3 id="153-RabbitMQ消息投递失败，你们怎么处理"><a href="#153-RabbitMQ消息投递失败，你们怎么处理" class="headerlink" title="153.RabbitMQ消息投递失败，你们怎么处理"></a>153.RabbitMQ消息投递失败，你们怎么处理</h3><p>我们可以设置confirm回调和 returned 回调</p>
<p>比如说，可以在发送消息的时候，把消息详情包括交换机名，路由键，都保存到一个表中，状态设置为发送中，如果在confirm方法中ack为false,代表发送到交换机失败 ，就把这个记录状态修改为发送失败</p>
<p>然后我们创建一个定时任务定时扫表，去读取发送失败的数据并重新发送，为了优化性能，我们设置重试次数3次，如果3次都失败了，我们可以采取人工干预</p>
<h3 id="154-为什么要使用Eureka-为什么要使用Ribbon-为什么要使用config配置中心"><a href="#154-为什么要使用Eureka-为什么要使用Ribbon-为什么要使用config配置中心" class="headerlink" title="154.为什么要使用Eureka   为什么要使用Ribbon   为什么要使用config配置中心"></a>154.为什么要使用Eureka   为什么要使用Ribbon   为什么要使用config配置中心</h3><p>在微服务系统中，各个服务之间是需要进行网络通信的，那么他们相互调用就得知道对方的通信地址。eureka就是专门来做做服务注册与发现，解决服务之间通信问题的</p>
<p>当一个微服务做了集群，也就是同一个服务名会对应多个地址，那么我们在调用的时候，应该调用哪一个就成了问题，Ribbon是一个负债均衡器，它可以按照负债均衡算法，向多个服务发起调用。当一个微服务有多个集群时，就可以使用它做请求的分发</p>
<p>在微服务系统中，服务数量很多，而每个服务都有自己的配置文件，管理起来很麻烦。用了配置中心就可以帮我们集中管理配置文件，它支持本地配置文件，也支持将配置文件放到远程仓库如git集中管理</p>
<h3 id="155-你们项目最大并发是多少"><a href="#155-你们项目最大并发是多少" class="headerlink" title="155.你们项目最大并发是多少"></a>155.你们项目最大并发是多少</h3><p>俺们项目是按照最高2000 QPS设计的，实际并发数运维在统计，俺也不太清楚</p>
<h3 id="156-你们项目最大表数量是多少"><a href="#156-你们项目最大表数量是多少" class="headerlink" title="156.你们项目最大表数量是多少"></a>156.你们项目最大表数量是多少</h3><p>俺们项目都有分库分表，按服务拆分多个数据库，对于有些数据量大的表，我们也是按照字段的使用频率，拆分成多个表，比如课程表拆分成课程主表，课程详情表，课程分类表等等。</p>
<p>但是有些表比如日志，流水相关的表，数据量还是很大的</p>
<h3 id="157-说一下security中的常用filter"><a href="#157-说一下security中的常用filter" class="headerlink" title="157.说一下security中的常用filter"></a>157.说一下security中的常用filter</h3><p>​        SecurityContextPersistenceFilter：请求开始会从SecurityContextRepository中获取SecurityContext对象并设置给SecurityContextHolder，在请求完处理成后将SecurityContextHolder持有的SecurityContext再保存到配置好的SecurityContextRepository中，同时清除SecurityContextHolder中的SecurityContext</p>
<p>​        UsernamePasswordAuthenticationFilter：默认拦截“/login”登录请求，将请求中的认证信息包括用户名，密码封装成UsernamePasswordAuthenticationToken，然后调用AuthenticationManager的认证方法进行认证</p>
<p>​        BasicAuthenticationFilter：处理 HTTP 请求的 BASIC 授权标头，如果身份验证成功，就把生成的Authentication对象放入SecurityContextHolder。如果设置了记住我，下次访问就不会走这里来了</p>
<p>​        RememberAuthenticationFilter：记住我，调用RememberMeServices的autoLogin方法自动登录</p>
<p>​        AnonymousAuthenticationFilter：匿名filter，检测SecurityContextHolder有没有Authentication对象，如果没有，就会创建一个AnonymousAuthenticationToken并保存到SecurityContextHolder</p>
<p>​        ExceptionTranslationFilter：处理filter链中的所有AccessDeniedException和AuthenticationException </p>
<p>​        FilterSecurityInterceptor：继承自AbstractSecurityInterceptor，通过调用AccessDecisionManager.decide方法进行授权</p>
<h3 id="158-说一下security的认证原理"><a href="#158-说一下security的认证原理" class="headerlink" title="158.说一下security的认证原理"></a>158.说一下security的认证原理</h3><p>​    首先，请求会经过UsernamePasswordAuthenticationFilter拦截，请求的用户名密码会封装成UsernamePasswordAuthenticationToken，过滤器将token提交给认证管理器AuthenticationManager进行认证</p>
<p>​    然后，认证管理器调用AuthenticationProvider进行认证，AuthenticationProvider再调用UserDetailsService获取到数据库中存储的用户信息UserDetails，然后调用密码编码器对密码进行比较，认证成功后封装Authentication</p>
<p>​    再后来，请求回到UsernamePasswordAuthenticationFilter，调用SecurityContextHolder将Authentication对象封装成SecurityContext并保存到SecurityContextHolder中</p>
<p>​    最后，请求回到SecurityContextPersistenceFilter，它会调用SecurityContextRepository将SecurityContext对象存储起来，再清理掉SecurityContextHolder中的信息</p>
<h3 id="159-Oauth2授权有几种方式，你们项目用的哪种"><a href="#159-Oauth2授权有几种方式，你们项目用的哪种" class="headerlink" title="159.Oauth2授权有几种方式，你们项目用的哪种"></a>159.Oauth2授权有几种方式，你们项目用的哪种</h3><p>​    授权码模式：它是功能最完整、流程最严密的授权模式</p>
<p>​    简化模式：跳过授权码，直接再浏览器端申请令牌</p>
<p>​    用户名密码模式：客户向客户端提供用户名密码，建立在用户对客户端高度信赖的基础上</p>
<p>​    客户端模式：客户端以自己的名义，要求服务提供商提供服务，你仔细一品，这其实也不存在授权一说了</p>
<p>我们项目中，用户登录使用的是用户名密码模式，服务内部临时调用使用的是客户端模式</p>
<h3 id="160-说一下security授权原理"><a href="#160-说一下security授权原理" class="headerlink" title="160.说一下security授权原理"></a>160.说一下security授权原理</h3><p>认证后的用户在访问受保护的资源，会经过FilterSecurityInterceptor，它会调用父类AbstractSecurityInterceptor的beforeInvocation方法开始授权</p>
<p>​    首先通过SecurityMetadataSource.getAttributes(object)，获取该资源所需要的权限</p>
<p>​    然后通过SecurityContextHolder.getContext().getAuthentication()，获取当前用户的权限</p>
<p>​    最后通过调用AccessDecisionManager.decide进行授权，它使用的是投票机制来决定用户是否有访问权限，投票通过，就能访问请求的资源。</p>
<h3 id="161-说一下你们课程搜索的那个业务方法的大致逻辑。"><a href="#161-说一下你们课程搜索的那个业务方法的大致逻辑。" class="headerlink" title="161.说一下你们课程搜索的那个业务方法的大致逻辑。"></a>161.说一下你们课程搜索的那个业务方法的大致逻辑。</h3><p>首先，课程在发布的时候，就同时将课程信息存放到ES中，信息中包括了需要查询的字段，如课程标题，课程分类，课程等级，机构名，销量，浏览量，上线时间，价格等等</p>
<p>接下来，根据用户在前台发送的查询条件，在ES中搜索对应的课程，并作关键字高亮处理，排序和分页处理，然后返回前台</p>
<h3 id="162-你使用过ES的哪些聚合查询？"><a href="#162-你使用过ES的哪些聚合查询？" class="headerlink" title="162.你使用过ES的哪些聚合查询？"></a>162.你使用过ES的哪些聚合查询？</h3><p>指标聚合，比如求和，求最大值，最小值，平均数</p>
<p>数量统计聚合，计算满足条件数据的总条数，相当于sql中的count</p>
<p>去重聚合，它会计算非重复的数据个数，相当于sql中的distinct</p>
<p>桶聚合，它会将某个field的每个唯一值当成一个桶，并计算每个桶内的文档个数，相当于sql中的group by</p>
<p>最高权值聚合，它会匹配每组前n条数据，相当于sql中的group by后取出前n条</p>
<h3 id="163-ES高亮怎么做的？"><a href="#163-ES高亮怎么做的？" class="headerlink" title="163.ES高亮怎么做的？"></a>163.ES高亮怎么做的？</h3><p>使用HighlightBuilder对关键字作高亮处理，由于我们项目使用的是SpringBoot整合ES的jar包，结果没有进行高亮处理，我们使用ElasticsearchTemplate的queryForPage方法来获取结果，再手动进行分页封装返回前台</p>
<h3 id="164-说一下你对ConcurrentHashMap的理解"><a href="#164-说一下你对ConcurrentHashMap的理解" class="headerlink" title="164.说一下你对ConcurrentHashMap的理解"></a>164.说一下你对ConcurrentHashMap的理解</h3><p>ConcurrentHashMap，它是HashMap的线程安全，支持高并发的版本</p>
<p>在jdk1.7中，它是通过分段锁的方式来实现线程安全的。意思是将哈希表分成许多片段Segment，而Segment本质是一个可重入的互斥锁，所以叫做分段锁。</p>
<p>在jdk1.8中，它是采用了CAS操作和synchronized来实现的，而且每个Node节点的value和next都用了volatile关键字修饰，保证了可见性</p>
<h3 id="165-讲一下你们的微服务授权方案-你还知道有哪些方案吗？"><a href="#165-讲一下你们的微服务授权方案-你还知道有哪些方案吗？" class="headerlink" title="165.讲一下你们的微服务授权方案   你还知道有哪些方案吗？"></a>165.讲一下你们的微服务授权方案   你还知道有哪些方案吗？</h3><p>我们使用的是SpringSecurity+Oauth2+JWT，认证服务器负责颁发token，资源服务器负责认证和授权</p>
<p>或者也可以将认证工作交给网关zuul，资源服务器只负责授权工作。</p>
<p>另外常见的授权方案还有，单点登录，用户只用在某个服务上登录，访问其他服务时就不需要登录了，这就要求每个面向用户的服务都必须于认证服务交互，会产生大量重复的工作</p>
<p>分布式会话，它是将用户认证信息存储在共享容器比如redis中，通常会以会话作为key，当用户访问微服务时，就从redis中获取认证信息。这对安全存储有较高的要求，复杂度高</p>
<h3 id="166-讲一下你们微服务认证授权的整体流程"><a href="#166-讲一下你们微服务认证授权的整体流程" class="headerlink" title="166.讲一下你们微服务认证授权的整体流程"></a>166.讲一下你们微服务认证授权的整体流程</h3><p>客户端访问认证服务器，认证服务器验证用户名密码，然后颁发token</p>
<p>客户端保存token，并且每次访问服务时都携带token</p>
<p>资源服务器接收到客户端请求，会验证token信息，认证通过后返回资源</p>
<h3 id="167-你们为啥要用JWT"><a href="#167-你们为啥要用JWT" class="headerlink" title="167.你们为啥要用JWT"></a>167.你们为啥要用JWT</h3><p>一个字，安全</p>
<p>我们做了认证授权后，每次客户端访问资源服务器，都需要远程调用认证服务器进行token的校验和授权，才能访问到资源。这是很好性能的，因此我们考虑将签名信息直接保存到客户端，那就不需要每次都向认证服务器认证授权了。</p>
<p>但是这有有一个新的问题，这些敏感数据赤裸裸的存到客户端不安全！而JWT就能解决这个问题。它支持非对称加密算法对信息加密，保证了信息安全</p>
<p>另外，JWT以json对象的形式传递信息，解析更方便</p>
<p>可以再令牌中定义内容，方便扩展</p>
<h3 id="168-Oauth2的授权模式有哪些，分别使用在什么场景？"><a href="#168-Oauth2的授权模式有哪些，分别使用在什么场景？" class="headerlink" title="168.Oauth2的授权模式有哪些，分别使用在什么场景？"></a>168.Oauth2的授权模式有哪些，分别使用在什么场景？</h3><p>​    授权码模式：它是功能最完整、流程最严密的授权模式</p>
<p>​    简化模式：跳过授权码，直接再浏览器端申请令牌</p>
<p>​    用户名密码模式：客户向客户端提供用户名密码，建立在用户对客户端高度信赖的基础上</p>
<p>​    客户端模式：客户端以自己的名义，要求服务提供商提供服务</p>
<h3 id="169-Oauth2认证，如果Token过期了你们是怎么处理的"><a href="#169-Oauth2认证，如果Token过期了你们是怎么处理的" class="headerlink" title="169.Oauth2认证，如果Token过期了你们是怎么处理的"></a>169.Oauth2认证，如果Token过期了你们是怎么处理的</h3><p>首先，我们会在前端设置axios后置拦截，检查是否是token过期，判断一下如果返回401，就代表token过期了</p>
<p>然后从localStorage中获取刷新refresh_token，并发送请求获取新的token</p>
<p>后台接收到前台的刷新token请求，拼接完整的刷新token的url，发送http请求获取到新的token并返回客户端</p>
<p>客户端收到新的token就把旧的token覆盖掉，最后把之前的请求再重新发送一次</p>
<h3 id="170-Oauth2认证，如果Token被盗了怎么办？"><a href="#170-Oauth2认证，如果Token被盗了怎么办？" class="headerlink" title="170.Oauth2认证，如果Token被盗了怎么办？"></a>170.Oauth2认证，如果Token被盗了怎么办？</h3><p>首先，我们需要对token设置过期时间，这个时间可以根据需要设置短一点</p>
<p>然后，可以在token中加入客户身份标识，比如客户的ip地址，如果短时间内ip地址频繁变动，就标记为异常状态，并给用户发送信息，提示账户有风险</p>
<h3 id="171-说一下Eureka的自我保护"><a href="#171-说一下Eureka的自我保护" class="headerlink" title="171.说一下Eureka的自我保护"></a>171.说一下Eureka的自我保护</h3><p>为了防止服务被误删除，Eureka不会立即删除过时的服务数据。这种机制可能会导致客户端从注册中心获取到已经下线的服务并发起调用而导致错误，因此在开发阶段我们可以关闭自我保护机制。在生产环境中，我们需要打开自我保护，因为它可以防止因为网络波动，服务没有及时续约而造成的服务误删除问题。</p>
<h3 id="172-说下Ribbon和Feign的区别呢？"><a href="#172-说下Ribbon和Feign的区别呢？" class="headerlink" title="172.说下Ribbon和Feign的区别呢？"></a>172.说下Ribbon和Feign的区别呢？</h3><p>Ribbon和Feign都是SpringCloud Netflix中实现负载均衡的组件，不同点在于</p>
<p>Ribbon是需要我们手动构建http请求，根据目标服务名通过负载均衡算法直接调用目标服务，</p>
<p>Feign是采用接口的方式，将需要调用的目标服务方法定义成抽象方法，路径，服务名，形参列表，返回值类型需要保持一致。我们只需要调用接口中的方法就可以了。它会自动帮我们生成jdk动态代理，为每个方法生成RequestTemplate并封装url和请求参数，使用负载均衡算法发起调用</p>
<p>Ribbon的实现方式，一般配合RestTemplate发起http请求，我们需要在注册RestTemplate的Bean的方法上加@LoadBalanced，使它具有负载均衡的能力</p>
<p>Feign的实现方式，是在主启动类上加@EnableFeignClients，在客户端接口上加注解@FeignClient</p>
<h3 id="173-Spring-SpringBoot和SpringCloud的关系以及区别"><a href="#173-Spring-SpringBoot和SpringCloud的关系以及区别" class="headerlink" title="173.Spring,SpringBoot和SpringCloud的关系以及区别"></a>173.Spring,SpringBoot和SpringCloud的关系以及区别</h3><p>Spring是一个开源的轻量级控制反转和面向切面编程的容器框架。轻量级是说它开发使用简单，功能强大。控制反转是指将对象的创建，销毁控制交给ioc容器，方便解耦合，降低维护难度，面向切面编程是指将相同的逻辑横向抽取出来，可以对一些通用业务如事务，日志进行集中管理。</p>
<p>Springboot是一个基于spring的框架，对spring做了大量简化，使开发流程更快，更高效。比如它大量简化maven依赖，基于注解配置（JavaConfig）无需XML，内嵌Tomcat，部署流程简单，打包和部署更加灵活，允许独立运行</p>
<p>SpringCloud是基于SpringBoot实现的，用于微服务架构中管理和协调服务的，它是一系列框架的有序集合，它为开发者提供了一系列工具，例如服务发现与注册，配置中心，网关，负载均衡，熔断器，链路追踪等等，让微服务架构落地变得更简单</p>
<h3 id="174-ES的keyword和text区别"><a href="#174-ES的keyword和text区别" class="headerlink" title="174.ES的keyword和text区别"></a>174.ES的keyword和text区别</h3><p>keyword：不分词，直接建立索引，支持模糊查询，精确查询，聚合查询</p>
<p>text：分词后建立索引，支持模糊查询，精确查询，不支持聚合查询</p>
<p>keyword通常用于通常用于存储年龄，性别，邮编，邮箱号码等等，直接将完整数据保存的场景</p>
<p>text通常存储全文搜索的数据，例如地址，文章内容的保存</p>
<h3 id="175-常见Http状态码"><a href="#175-常见Http状态码" class="headerlink" title="175.常见Http状态码"></a>175.常见Http状态码</h3><p>200 成功返回状态</p>
<p>301 永久重定向，被请求的资源永久移动到新位置</p>
<p>302 临时重定向，被请求的资源临时移动到新的位置，项目中使用了oauth2，对目标资源访问无权限时就会见到，它是会重定向到授权地址</p>
<p>401 无权限访问</p>
<p>403 禁止访问，服务器已经接收到请求，但拒绝执行</p>
<p>404 找不到该资源</p>
<p>500 服务器内部错误 zuul找不到服务名就会见到</p>
<p>503 服务器内部错误 服务器维护或者过载</p>
<p>504 网关超时 </p>
<h3 id="176-什么是事务"><a href="#176-什么是事务" class="headerlink" title="176.什么是事务"></a>176.什么是事务</h3><p>一组对数据库的操作，要么全部成功，要么全部失败</p>
<p>举个栗子，比如A向B转账，A账户的钱少了，B账户的钱就应该对应增加，这就转账成功了，如果A账户的钱少了，由于网络波动等因素转账失败了，B账户的钱没有增加，那么A账户就应该恢复成原先的状态</p>
<h3 id="177-事务的四大特性"><a href="#177-事务的四大特性" class="headerlink" title="177.事务的四大特性"></a>177.事务的四大特性</h3><p>原子性：指的是一个事务应该是一个最小的无法分割的单元，不允许部分成功部分失败，只能同时成功，或者同时失败</p>
<p>持久性：一旦提交事务，那么数据就应该持久化，保证数据不会丢失</p>
<p>隔离性：两个事务修改同一个数据，必须按顺序执行，并且前一个事务如果未完成，那么中间状态对另一个事务不可见</p>
<p>一致性：要求任何写到数据库的数据都必须满足预先定义的规则，它基于其他三个特性实现的</p>
<h3 id="178-InnoDB如何保证原子性和持久性的"><a href="#178-InnoDB如何保证原子性和持久性的" class="headerlink" title="178.InnoDB如何保证原子性和持久性的"></a>178.InnoDB如何保证原子性和持久性的</h3><p>通过undo log 保证事务的原子性，redo log保证事务的持久性</p>
<p>undo log是回滚日志，记录的是回滚需要的信息，redo log记录的是新数据的备份</p>
<p>当事务开始时，会先保存一个undo log，再执行修改，并保存一个redo log，最后再提交事务。如果系统崩溃数据保存失败了，可以根据redo log中的内容，从新恢复到最新状态，如果事务需要回滚，就根据undo log 回滚到之前的状态</p>
<h3 id="179事务并发问题有哪些"><a href="#179事务并发问题有哪些" class="headerlink" title="179事务并发问题有哪些"></a>179事务并发问题有哪些</h3><p>脏读：事务A读到了事务B修改还未提交的数据</p>
<p>幻读，也叫虚读：事务A两次读取相同条件的数据，两次查询到的数据条数不一致，是由于事务B再这两次查询中插入或删除了数据造成的</p>
<p>不可重复读：事务A两次读取相同条件的数据，结果读取出不同的结果，是由于事务B再这两次查询中修改了数据造成的</p>
<p>第一类丢失更新：也叫回滚丢失，事务A和事务B更新同一条数据，事务B先完成了修改，此时事务A异常终止，回滚后造成事务B的更新也丢失了</p>
<p>第二类丢失更新：也叫覆盖丢失，事务A和事务B更新同一条数据，事务B先完成了修改，事务A再次修改并提交，把事务B提交的数据给覆盖了</p>
<h3 id="180-事务隔离级别有哪些，分别能解决什么问题"><a href="#180-事务隔离级别有哪些，分别能解决什么问题" class="headerlink" title="180.事务隔离级别有哪些，分别能解决什么问题"></a>180.事务隔离级别有哪些，分别能解决什么问题</h3><p>读未提交：事务读不阻塞其他事务的读和写，事务写阻塞其他事务的写但不阻塞读，能解决第一类丢失更新的问题，</p>
<p>读已提交：事务读不会阻塞其他事务读和写，事务写会阻塞其他事务的读和写，能解决第一类丢失更新，脏读的问题</p>
<p>可重复读：事务读会阻塞其他事务的写但不阻塞读，事务写会阻塞其他事务读和写，能解决第一类丢失更新，脏读，不可重复读，第二类丢失更新问题</p>
<p>串行化：使用表级锁，让事务一个一个的按顺序执行，能解决以上所有并发安全问题</p>
<h3 id="181-MySql的InnoDB是如何保证原子性的"><a href="#181-MySql的InnoDB是如何保证原子性的" class="headerlink" title="181.MySql的InnoDB是如何保证原子性的"></a>181.MySql的InnoDB是如何保证原子性的</h3><p>利用了undo log实现的</p>
<p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子</p>
<h3 id="182-MySql的InnoDB是如何保证持久性的"><a href="#182-MySql的InnoDB是如何保证持久性的" class="headerlink" title="182.MySql的InnoDB是如何保证持久性的"></a>182.MySql的InnoDB是如何保证持久性的</h3><p>利用了redo log实现的</p>
<p>redo log记录的是新数据的备份，在事务提交前，需要将Redo Log持久化，当系统崩溃时，可以根据redo Log的内容，将所有数据恢复到最新的状态</p>
<h3 id="183-说一下事务的执行流程-Undolog-Redolog"><a href="#183-说一下事务的执行流程-Undolog-Redolog" class="headerlink" title="183.说一下事务的执行流程(Undolog+Redolog)"></a>183.说一下事务的执行流程(Undolog+Redolog)</h3><p>假设有A=1，B=2，两个数据，现在有个事务把A修改为3，B修改为4，那么事务的执行流程：</p>
<p>当事务开始时，会首先记录A=1到undo log，记录A=3到redo log，和记录B=2到undo log，记录B=4到redo log，然后再将redo log写入磁盘，最终事务提交</p>
<h3 id="184-解释一下事务并发丢失更新问题，·如何解决"><a href="#184-解释一下事务并发丢失更新问题，·如何解决" class="headerlink" title="184.解释一下事务并发丢失更新问题，·如何解决"></a>184.解释一下事务并发丢失更新问题，·如何解决</h3><p>第一类丢失更新：也叫回滚丢失，事务A和事务B更新同一条数据，事务B先完成了修改，此时事务A异常终止，回滚后造成事务B的更新也丢失了</p>
<p>第二类丢失更新：也叫覆盖丢失，事务A和事务B更新同一条数据，事务B先完成了修改，事务A再次修改并提交，把事务B提交的数据给覆盖了</p>
<p>SQL标准中的四种隔离级别，读未提交，读已提交，可重复读，串行化，都能解决第一类数据更新丢失问题</p>
<p>对于第二类丢失更新问题，可以使用悲观锁也就是串行化来解决，也可以使用乐观锁的方式，比如加一个版本号管理来解决</p>
<h3 id="185-InnoDB事务隔离的实现原理是什么"><a href="#185-InnoDB事务隔离的实现原理是什么" class="headerlink" title="185.InnoDB事务隔离的实现原理是什么"></a>185.InnoDB事务隔离的实现原理是什么</h3><p>隔离的实现主要利用了读写锁和MVCC机制</p>
<p>读写锁，要求在每次读操作时需要获取一个共享锁，写操作时需要获取一个写锁。共享锁之间不会产生互斥，共享锁和写锁，写锁与写锁之间会产生互斥。当产生锁竞争时，需要等一个操作的锁释放，另一个操作才能获得锁</p>
<p>MVCC，多版本并发控制，它是在读取数据时通过一种类似快照的方式将数据保存下来，不同的事务看到的快照版本是不一样的，即使其他事务修改了数据，但是对本事务仍然是不可见的，它只会看到第一次查询到的数据</p>
<p>可重复读是只在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照</p>
<h3 id="186-什么是分布式事务，-分布式事务你知道哪些解决方案？-这些方案如何选型"><a href="#186-什么是分布式事务，-分布式事务你知道哪些解决方案？-这些方案如何选型" class="headerlink" title="186.什么是分布式事务，   分布式事务你知道哪些解决方案？   这些方案如何选型"></a>186.什么是分布式事务，   分布式事务你知道哪些解决方案？   这些方案如何选型</h3><p>分布式事务，指的是在分布式环境中，一个请求可能涉及到对多个数据库的写操作，要保证多数据库的一致性就需要用到分布式事务</p>
<p>常见的分布式事务解决方案，2PC，TCC，可靠消息最终一致性，最大努力通知</p>
<p>2PC，它将整个事务流程分为两个阶段，P指的是准备阶段，C指的是提交阶段。它是一个阻塞协议，不适用于并发较高，事务生命周期长的分布式事务。</p>
<p>TCC，它是基于补偿性事务的AP系统的一种实现，补偿也就是说先按照预定方案执行，如果失败了就走补偿方案。它可以自己定义数据操作的粒度，但是对应用的侵入性强，可以用在登录送积分，送优惠券等等场景</p>
<p>可靠消息最终一致性，指的是当事务发起方执行完本地事务后，就发出一条消息通知其他参与方，并且他们一定能接收到消息并处理事务。适合执行周期长，并且实时性要求不高的场景</p>
<p>最大努力通知，是在不影响主业务的情况下，尽可能的保证数据的一致性，它适用于一些最终一致性敏感度低的业务，比如支付结果通知</p>
<h3 id="187-什么是2pc-基于什么协议，有什么缺点？"><a href="#187-什么是2pc-基于什么协议，有什么缺点？" class="headerlink" title="187.什么是2pc,基于什么协议，有什么缺点？"></a>187.什么是2pc,基于什么协议，有什么缺点？</h3><p>2PC，是将整个事务流程分为两个阶段，P指的是准备阶段，C指的是提交阶段。它常见的标准有XA，JTA，Seata</p>
<p>由DTP模型定义事务管理器TM和资源管理器RM之间通讯的接口规范叫做XA，它规定的交互方式是酱紫的：应用程序AP通过TM提交和回滚事务，TM通过XA接口来通知RM数据库事务的开始，结束，提交，回滚</p>
<p>2PC能保证分布式事务的原子性，但是也有很多缺陷</p>
<p>比如，在第一阶段，如果参与者迟迟不回复协调者，就会造成事务的阻塞，性能不好</p>
<p>比如，在第二阶段，如果事务协调者发出提交事务指令后宕机，一部分参与者收到消息提交了事务，另一部分没有收到消息没有提交事务，这就会导致数据不一致</p>
<p>再比如，在第二阶段，如果事务协调者发出提交事务指令后宕机，收到指令的参与者也宕机了，我们就不能确定事务的执行结果，究竟有没有提交</p>
<h3 id="188-Seata相比传统2PC有什么区别，以及优点？"><a href="#188-Seata相比传统2PC有什么区别，以及优点？" class="headerlink" title="188.Seata相比传统2PC有什么区别，以及优点？"></a>188.Seata相比传统2PC有什么区别，以及优点？</h3><p>Seata是由阿里中间件团队发起的开源项目Fescar更名而来，是一个开源的分布式事务框架，它通过对本地关系数据库的分支事务协调，来驱动完成全局事务</p>
<p>Seata的主要优点是性能好，不会长时间占用链接资源，对业务零入侵</p>
<p>与传统的2PC的区别主要两方面</p>
<p>在架构层次方面，传统的2PC方案的RM本质就是数据库自身，而Seata的RM是以jar包形式作为中间件层部署在应用程序上</p>
<p>在两阶段提交上方面，传统2PC方案是在第二阶段完成才释放资源，而Seata是在第一阶段就将本地事务提交，提高了效率</p>
<h3 id="189-Seata的TC-TM-RM的含义，以及作用？"><a href="#189-Seata的TC-TM-RM的含义，以及作用？" class="headerlink" title="189.Seata的TC,TM,RM的含义，以及作用？"></a>189.Seata的TC,TM,RM的含义，以及作用？</h3><p>TC：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚</p>
<p>TM：事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向TC发起全局提交或全局回滚的指令</p>
<p>RM：控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分支事务的提交和回滚</p>
<h3 id="190-你知道TCC吗，它有什么样的优缺点？"><a href="#190-你知道TCC吗，它有什么样的优缺点？" class="headerlink" title="190.你知道TCC吗，它有什么样的优缺点？"></a>190.你知道TCC吗，它有什么样的优缺点？</h3><p>TCC是基于补偿型事务的AP系统的一种实现。补偿指的先按照事先预定的方案去执行，如果失败了就走补偿方案</p>
<p>它的优点是异步执行效率高，它能对分布式事务中的各个资源分别锁定，分别提交与释放</p>
<p>它的缺点是对应用的侵入性强，改动成本高，实现难度大</p>
<h3 id="191-解释一下Seata的工作原理"><a href="#191-解释一下Seata的工作原理" class="headerlink" title="191.解释一下Seata的工作原理"></a>191.解释一下Seata的工作原理</h3><p>假设有服务A需要调用服务B，且两个服务都需要修改各自的数据库</p>
<p>​    A服务的TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</p>
<p>​    A服务的RM向TC注册分支事务，并将其纳入XID对应全局事务的管辖</p>
<p>​    A服务执行分支事务</p>
<p>​    当调用B服务时，B服务的RM向TC注册分支事务，该分支事务执行，并将其纳入XID对应全局事务的管辖</p>
<p>​    B服务执行分支事务，执行完毕后，返回A服务</p>
<h3 id="192-你能简单描述一下你在项目中是如何集成Seata的吗"><a href="#192-你能简单描述一下你在项目中是如何集成Seata的吗" class="headerlink" title="192.你能简单描述一下你在项目中是如何集成Seata的吗"></a>192.你能简单描述一下你在项目中是如何集成Seata的吗</h3><p>事务协调器：安装并启动Seata客户端</p>
<p>主业务端：</p>
<p>​    第一步，导入Seata依赖</p>
<p>​    第二步，yml中配置事务组名，同时需要添加配置文件file.conf，registry.conf，需要注意yml中事务组名与file.comf中的事务组名一致</p>
<p>​    第三步，配置DataSource，需要适用Seata对DataSource进行代理</p>
<p>​    第四步，数据库中添加undo log日志表</p>
<p>​    第五步，业务方法上加注解@GlobalTransactional(rollbackFor = Exception.class)注解</p>
<p>事务参与者：</p>
<p>​    前四步与主业务端相同，第五步不需要了</p>
<h3 id="193-你说一下什么是分布式锁"><a href="#193-你说一下什么是分布式锁" class="headerlink" title="193.你说一下什么是分布式锁"></a>193.你说一下什么是分布式锁</h3><h3 id="194-分布式锁有哪些解决方案"><a href="#194-分布式锁有哪些解决方案" class="headerlink" title="194.分布式锁有哪些解决方案"></a>194.分布式锁有哪些解决方案</h3><h3 id="195-Redis如何实现分布式锁，用什么命令"><a href="#195-Redis如何实现分布式锁，用什么命令" class="headerlink" title="195.Redis如何实现分布式锁，用什么命令"></a>195.Redis如何实现分布式锁，用什么命令</h3><h3 id="196-Redis实现分布式锁可能会出现什么问题，如何解决"><a href="#196-Redis实现分布式锁可能会出现什么问题，如何解决" class="headerlink" title="196.Redis实现分布式锁可能会出现什么问题，如何解决"></a>196.Redis实现分布式锁可能会出现什么问题，如何解决</h3><h3 id="197-你项目中怎么使用分布式锁的"><a href="#197-你项目中怎么使用分布式锁的" class="headerlink" title="197.你项目中怎么使用分布式锁的"></a>197.你项目中怎么使用分布式锁的</h3><h3 id="198-了解Redission的看门狗原理吗？"><a href="#198-了解Redission的看门狗原理吗？" class="headerlink" title="198.了解Redission的看门狗原理吗？"></a>198.了解Redission的看门狗原理吗？</h3><h3 id="199-你知道zookeeper实现分布式锁吗？"><a href="#199-你知道zookeeper实现分布式锁吗？" class="headerlink" title="199.你知道zookeeper实现分布式锁吗？"></a>199.你知道zookeeper实现分布式锁吗？</h3><h3 id="200-你在项目中如果使用ZK实现分布式锁的？"><a href="#200-你在项目中如果使用ZK实现分布式锁的？" class="headerlink" title="200.你在项目中如果使用ZK实现分布式锁的？"></a>200.你在项目中如果使用ZK实现分布式锁的？</h3><h3 id="201-如果没有Redis和zookeeper怎么实现分布式锁？"><a href="#201-如果没有Redis和zookeeper怎么实现分布式锁？" class="headerlink" title="201.如果没有Redis和zookeeper怎么实现分布式锁？"></a>201.如果没有Redis和zookeeper怎么实现分布式锁？</h3><h3 id="202-你们数据库和Redis的数据一致性怎么做的"><a href="#202-你们数据库和Redis的数据一致性怎么做的" class="headerlink" title="202.你们数据库和Redis的数据一致性怎么做的"></a>202.你们数据库和Redis的数据一致性怎么做的</h3><h3 id="203-了解缓存击穿，穿透，雪崩吗？怎么处理？"><a href="#203-了解缓存击穿，穿透，雪崩吗？怎么处理？" class="headerlink" title="203.了解缓存击穿，穿透，雪崩吗？怎么处理？"></a>203.了解缓存击穿，穿透，雪崩吗？怎么处理？</h3><h3 id="204-你们ES和数据库的数据一致性怎么做的？"><a href="#204-你们ES和数据库的数据一致性怎么做的？" class="headerlink" title="204.你们ES和数据库的数据一致性怎么做的？"></a>204.你们ES和数据库的数据一致性怎么做的？</h3><p>1.秒杀的整体流程详细说一下 </p>
<p>2.你们这个接口QPS是多少 </p>
<p>3.如果流量更高，比如：每秒10W请求，应该怎么处理 </p>
<p>4.说一下支付超时处理方案？延迟队列和死信队列是什么意思？ </p>
<p>5.整个秒杀流程你用了几个队列，分别用来存储什么东西 </p>
<p>6.秒杀成功，返回给用户的数据是什么？ </p>
<p>7.你们怎么处理超卖，少卖的？</p>
<h3 id="1-你知道BIO-NIO-AIO么？讲一下你的理解"><a href="#1-你知道BIO-NIO-AIO么？讲一下你的理解" class="headerlink" title="1.你知道BIO,NIO,AIO么？讲一下你的理解"></a>1.你知道BIO,NIO,AIO么？讲一下你的理解</h3><h3 id="2-如何提高接口的qps"><a href="#2-如何提高接口的qps" class="headerlink" title="2.如何提高接口的qps"></a>2.如何提高接口的qps</h3><p>​    一方面：提高并发数    </p>
<p>​        1.多线程,尽量用线程池           (线程个数：CPU核数 / (1 - 阻塞系数(IO密集型接近1，计算密集型接近0)))    </p>
<p>​        2.适当调整连接数(Tomcat,Redis，Mysql等连接数)    </p>
<p>​        3.集群  </p>
<p>​    二方面：提高接口响应速度    </p>
<p>​        1.减少和数据库交互，使用Redis代替    </p>
<p>​        2.使用异步方案，比如MQ    </p>
<p>​        3.使用并发编程，多个线程同时工作    </p>
<p>​        4.减少服务的调用链    </p>
<p>​        5.实在要连数据库，考虑数据库优化</p>


            <!-- Tags -->
            


<div class="tags">
    
</div>



            <!-- Comments -->
            <div>
                




    <hr />
    <h3>Comments:</h3>
    <div id="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine@1.1.7/dist/Valine.min.js'></script>
    <script>
    new Valine({
        el: '#valine' ,
        notify:false,
        verify:false,
        app_id: 'ohKdNvnATs6xIpXGmi3zoR8g-gzGzoHsz',
        app_key: 'Gt7d5LTaoWzVHvHj58eHJbwu',
        placeholder: 'Just go go',
        path:window.location.pathname,
        avatar:'mm' 
    });
    </script>

            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->

<script src="/js/jquery.js"></script>


<!-- Custom Code -->

<script src="/js/main.js"></script>


<!-- Gallery -->
<script src="https://cdn.bootcdn.net/ajax/libs/featherlight/1.5.0/featherlight.gallery.min.css" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


</body>

</html>